<html lang="en">
<head>
<title>Nettle: a low-level cryptographic library</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="description" content="Nettle: a low-level cryptographic library">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual is for the Nettle library (version 2.3), a
low-level cryptographic library.

Originally written 2001 by Niels Möller, updated 2011.

     This manual is placed in the public domain. You may freely copy
     it, in whole or in part, with or without modification. Attribution
     is appreciated, but not required.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<h1 class="settitle">Nettle: a low-level cryptographic library</h1>
   <div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">Nettle</a>
<li><a name="toc_Introduction" href="#Introduction">1 Introduction</a>
<li><a name="toc_Copyright" href="#Copyright">2 Copyright</a>
<li><a name="toc_Conventions" href="#Conventions">3 Conventions</a>
<li><a name="toc_Example" href="#Example">4 Example</a>
<li><a name="toc_Linking" href="#Linking">5 Linking</a>
<li><a name="toc_Reference" href="#Reference">6 Reference</a>
<ul>
<li><a href="#Hash-functions">6.1 Hash functions</a>
<ul>
<li><a href="#Hash-functions">6.1.1 <acronym>MD5</acronym></a>
<li><a href="#Hash-functions">6.1.2 <acronym>MD2</acronym></a>
<li><a href="#Hash-functions">6.1.3 <acronym>MD4</acronym></a>
<li><a href="#Hash-functions">6.1.4 <acronym>RIPEMD160</acronym></a>
<li><a href="#Hash-functions">6.1.5 <acronym>SHA1</acronym></a>
<li><a href="#Hash-functions">6.1.6 <acronym>SHA256</acronym></a>
<li><a href="#Hash-functions">6.1.7 <acronym>SHA224</acronym></a>
<li><a href="#Hash-functions">6.1.8 <acronym>SHA512</acronym></a>
<li><a href="#Hash-functions">6.1.9 <acronym>SHA384</acronym></a>
<li><a href="#Hash-functions">6.1.10 <code>struct nettle_hash</code></a>
</li></ul>
<li><a href="#Cipher-functions">6.2 Cipher functions</a>
<ul>
<li><a href="#Cipher-functions">6.2.1 AES</a>
<li><a href="#Cipher-functions">6.2.2 ARCFOUR</a>
<li><a href="#Cipher-functions">6.2.3 ARCTWO</a>
<li><a href="#Cipher-functions">6.2.4 BLOWFISH</a>
<li><a href="#Cipher-functions">6.2.5 Camellia</a>
<li><a href="#Cipher-functions">6.2.6 CAST128</a>
<li><a href="#Cipher-functions">6.2.7 DES</a>
<li><a href="#Cipher-functions">6.2.8 DES3</a>
<li><a href="#Cipher-functions">6.2.9 SERPENT</a>
<li><a href="#Cipher-functions">6.2.10 TWOFISH</a>
<li><a href="#Cipher-functions">6.2.11 <code>struct nettle_cipher</code></a>
</li></ul>
<li><a href="#Cipher-modes">6.3 Cipher modes</a>
<ul>
<li><a href="#CBC">6.3.1 Cipher Block Chaining</a>
<li><a href="#CTR">6.3.2 Counter mode</a>
<li><a href="#GCM">6.3.3 Galois counter mode</a>
<ul>
<li><a href="#GCM">6.3.3.1 General <acronym>GCM</acronym> interface</a>
<li><a href="#GCM">6.3.3.2 <acronym>GCM</acronym> helper macros</a>
<li><a href="#GCM">6.3.3.3 <acronym>GCM</acronym>-<acronym>AES</acronym> interface</a>
</li></ul>
</li></ul>
<li><a href="#Keyed-hash-functions">6.4 Keyed Hash Functions</a>
<ul>
<li><a href="#Keyed-hash-functions">6.4.1 <acronym>HMAC</acronym></a>
<li><a href="#Keyed-hash-functions">6.4.2 Concrete <acronym>HMAC</acronym> functions</a>
<ul>
<li><a href="#Keyed-hash-functions">6.4.2.1 <acronym>HMAC-MD5</acronym></a>
<li><a href="#Keyed-hash-functions">6.4.2.2 <acronym>HMAC-RIPEMD160</acronym></a>
<li><a href="#Keyed-hash-functions">6.4.2.3 <acronym>HMAC-SHA1</acronym></a>
<li><a href="#Keyed-hash-functions">6.4.2.4 <acronym>HMAC-SHA256</acronym></a>
<li><a href="#Keyed-hash-functions">6.4.2.5 <acronym>HMAC-SHA512</acronym></a>
</li></ul>
</li></ul>
<li><a href="#Public_002dkey-algorithms">6.5 Public-key algorithms</a>
<ul>
<li><a href="#RSA">6.5.1 <acronym>RSA</acronym></a>
<li><a href="#RSA">6.5.2 Nettle's <acronym>RSA</acronym> support</a>
<li><a href="#DSA">6.5.3 Nettle's <acronym>DSA</acronym> support</a>
<li><a href="#DSA">6.5.4 Nettle's <acronym>DSA</acronym> support</a>
</li></ul>
<li><a href="#Randomness">6.6 Randomness</a>
<ul>
<li><a href="#Randomness">6.6.1 Yarrow</a>
</li></ul>
<li><a href="#Miscellaneous-functions">6.7 Miscellaneous functions</a>
<li><a href="#Compatibility-functions">6.8 Compatibility functions</a>
</li></ul>
<li><a name="toc_Nettle-soup" href="#Nettle-soup">7 Traditional Nettle Soup</a>
<li><a name="toc_Installation" href="#Installation">8 Installation</a>
<li><a name="toc_Index" href="#Index">Function and Concept Index</a>
</li></ul>
</div>



<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Introduction">Introduction</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dir">(dir)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="unnumbered">Nettle</h2>

<p>This document describes the Nettle low-level cryptographic library. You
can use the library directly from your C programs, or write or use an
object-oriented wrapper for your favorite language or application.

   <p>This manual is for the Nettle library (version 2.3), a
low-level cryptographic library.

   <p>Originally written 2001 by Niels Möller, updated 2011.

   <blockquote>
This manual is placed in the public domain. You may freely copy it, in
whole or in part, with or without modification. Attribution is
appreciated, but not required. 
</blockquote>

<ul class="menu">
<li><a accesskey="1" href="#Introduction">Introduction</a>:                 What is Nettle? 
<li><a accesskey="2" href="#Copyright">Copyright</a>:                    Your rights. 
<li><a accesskey="3" href="#Conventions">Conventions</a>:                  General interface conventions. 
<li><a accesskey="4" href="#Example">Example</a>:                      An example program. 
<li><a accesskey="5" href="#Linking">Linking</a>:                      Linking with the libnettle and libhogweed. 
<li><a accesskey="6" href="#Reference">Reference</a>:                    All Nettle functions and features. 
<li><a accesskey="7" href="#Nettle-soup">Nettle soup</a>:                  For the serious nettle hacker. 
<li><a accesskey="8" href="#Installation">Installation</a>:                 How to install Nettle. 
<li><a accesskey="9" href="#Index">Index</a>:                        Function and concept index.

</li></ul>
<p>--- The Detailed Node Listing ---

<p>Reference

</p>
<ul class="menu">
<li><a href="#Hash-functions">Hash functions</a>
<li><a href="#Cipher-functions">Cipher functions</a>
<li><a href="#Cipher-modes">Cipher modes</a>
<li><a href="#Keyed-hash-functions">Keyed hash functions</a>
<li><a href="#Public_002dkey-algorithms">Public-key algorithms</a>
<li><a href="#Randomness">Randomness</a>
<li><a href="#Miscellaneous-functions">Miscellaneous functions</a>
<li><a href="#Compatibility-functions">Compatibility functions</a>

</li></ul>
<p>Cipher modes

</p>
<ul class="menu">
<li><a href="#CBC">CBC</a>
<li><a href="#CTR">CTR</a>
<li><a href="#GCM">GCM</a>

</li></ul>
<p>Public-key algorithms

</p>
<ul class="menu">
<li><a href="#RSA">RSA</a>:                          The RSA public key algorithm. 
<li><a href="#DSA">DSA</a>:                          The DSA digital signature algorithm.

   </ul>

<div class="node">
<a name="Introduction"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Copyright">Copyright</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">1 Introduction</h2>

<p>Nettle is a cryptographic library that is designed to fit easily in more
or less any context: In crypto toolkits for object-oriented languages
(C++, Python, Pike, ...), in applications like LSH or GNUPG, or even in
kernel space. In most contexts, you need more than the basic
cryptographic algorithms, you also need some way to keep track of available
algorithms, their properties and variants. You often have some algorithm
selection process, often dictated by a protocol you want to implement.

   <p>And as the requirements of applications differ in subtle and not so
subtle ways, an API that fits one application well can be a pain to use
in a different context. And that is why there are so many different
cryptographic libraries around.

   <p>Nettle tries to avoid this problem by doing one thing, the low-level
crypto stuff, and providing a <em>simple</em> but general interface to it. 
In particular, Nettle doesn't do algorithm selection. It doesn't do
memory allocation. It doesn't do any I/O.

   <p>The idea is that one can build several application and context specific
interfaces on top of Nettle, and share the code, test cases, benchmarks,
documentation, etc. Examples are the Nettle module for the Pike
language, and LSH, which both use an object-oriented abstraction on top
of the library.

   <p>This manual explains how to use the Nettle library. It also tries to
provide some background on the cryptography, and advice on how to best
put it to use.

<div class="node">
<a name="Copyright"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Conventions">Conventions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction">Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">2 Copyright</h2>

<p>Nettle is distributed under the GNU Lesser General Public License
(LGPL), see the file COPYING.LIB for details. A few of the individual
files are in the public domain. To find the current status of particular
files, you have to read the copyright notices at the top of the files.

   <p>This manual is in the public domain. You may freely copy it in whole or
in part, e.g., into documentation of programs that build on Nettle. 
Attribution, as well as contribution of improvements to the text, is of
course appreciated, but it is not required.

   <p>A list of the supported algorithms, their origins and licenses:

     <dl>
<dt><em>AES</em><dd>The implementation of the AES cipher (also known as rijndael) is written
by Rafael Sevilla. Assembler for x86 by Rafael Sevilla and
Niels Möller, Sparc assembler by Niels Möller. Released under the
LGPL.

     <br><dt><em>ARCFOUR</em><dd>The implementation of the ARCFOUR (also known as RC4) cipher is written
by Niels Möller. Released under the LGPL.

     <br><dt><em>ARCTWO</em><dd>The implementation of the ARCTWO (also known as RC2) cipher is written
by Nikos Mavroyanopoulos and modified by Werner Koch and Simon
Josefsson. Released under the LGPL.

     <br><dt><em>BLOWFISH</em><dd>The implementation of the BLOWFISH cipher is written by Werner Koch,
copyright owned by the Free Software Foundation. Also hacked by Simon
Josefsson and Niels Möller. Released under the LGPL.

     <br><dt><em>CAMELLIA</em><dd>The C implementation is by Nippon Telegraph and Telephone Corporation
(NTT), heavily modified by Niels Möller. Assembler for x86 and x86_64
by Niels Möller. Released under the LGPL.

     <br><dt><em>CAST128</em><dd>The implementation of the CAST128 cipher is written by Steve Reid. 
Released into the public domain.

     <br><dt><em>DES</em><dd>The implementation of the DES cipher is written by Dana L. How, and
released under the LGPL.

     <br><dt><em>MD2</em><dd>The implementation of MD2 is written by Andrew Kuchling, and hacked
some by Andreas Sigfridsson and Niels Möller. Python Cryptography
Toolkit license (essentially public domain).

     <br><dt><em>MD4</em><dd>This is almost the same code as for MD5 below, with modifications by
Marcus Comstedt. Released into the public domain.

     <br><dt><em>MD5</em><dd>The implementation of the MD5 message digest is written by Colin Plumb. 
It has been hacked some more by Andrew Kuchling and Niels Möller. 
Released into the public domain.

     <br><dt><em>RIPMED160</em><dd>The implementation of RIPEMD160 message digest is based on the code in
libgcrypt, copyright owned by the Free Software Foundation. Ported to
Nettle by Andres Mejia. Released under the LGPL.

     <br><dt><em>SERPENT</em><dd>The implementation of the SERPENT cipher is based on the code in libgcrypt,
copyright owned by the Free Software Foundation. Adapted to Nettle by
Simon Josefsson and heavily modified by Niels Möller. Assembly for
x86_64 by Niels Möller. Released under the LGPL.

     <br><dt><em>SHA1</em><dd>The C implementation of the SHA1 message digest is written by Peter
Gutmann, and hacked some more by Andrew Kuchling and Niels Möller. 
Released into the public domain. Assembler for x86 by Niels Möller,
released under the LGPL.

     <br><dt><em>SHA224, SHA256, SHA384, and SHA512</em><dd>Written by Niels Möller, using Peter Gutmann's SHA1 code as a model. 
Released under the LGPL.

     <br><dt><em>TWOFISH</em><dd>The implementation of the TWOFISH cipher is written by Ruud de Rooij. 
Released under the LGPL.

     <br><dt><em>RSA</em><dd>Written by Niels Möller, released under the LGPL. Uses the GMP library
for bignum operations.

     <br><dt><em>DSA</em><dd>Written by Niels Möller, released under the LGPL. Uses the GMP library
for bignum operations. 
</dl>

<div class="node">
<a name="Conventions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Example">Example</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Copyright">Copyright</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">3 Conventions</h2>

<p>For each supported algorithm, there is an include file that defines a
<em>context struct</em>, a few constants, and declares functions for
operating on the context. The context struct encapsulates all information
needed by the algorithm, and it can be copied or moved in memory with no
unexpected effects.

   <p>For consistency, functions for different algorithms are very similar,
but there are some differences, for instance reflecting if the key setup
or encryption function differ for encryption and decryption, and whether
or not key setup can fail. There are also differences between algorithms
that don't show in function prototypes, but which the application must
nevertheless be aware of. There is no big difference between the
functions for stream ciphers and for block ciphers, although they should
be used quite differently by the application.

   <p>If your application uses more than one algorithm of the same type, you
should probably create an interface that is tailor-made for your needs,
and then write a few lines of glue code on top of Nettle.

   <p>By convention, for an algorithm named <code>foo</code>, the struct tag for the
context struct is <code>foo_ctx</code>, constants and functions uses prefixes
like <code>FOO_BLOCK_SIZE</code> (a constant) and <code>foo_set_key</code> (a
function).

   <p>In all functions, strings are represented with an explicit length, of
type <code>unsigned</code>, and a pointer of type <code>uint8_t *</code> or
<code>const uint8_t *</code>. For functions that transform one string to
another, the argument order is length, destination pointer and source
pointer. Source and destination areas are of the same length. Source and
destination may be the same, so that you can process strings in place,
but they <em>must not</em> overlap in any other way.

   <p>Many of the functions lack return value and can never fail. Those
functions which can fail, return one on success and zero on failure.

<!-- FIXME: Say something about the name mangling. -->
<div class="node">
<a name="Example"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Linking">Linking</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Conventions">Conventions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">4 Example</h2>

<p>A simple example program that reads a file from standard input and
writes its SHA1 checksum on standard output should give the flavor of
Nettle.

<pre class="example"><pre class="verbatim">     #include &lt;stdio.h>
     #include &lt;stdlib.h>
     
     #include &lt;nettle/sha.h>
     
     #define BUF_SIZE 1000
     
     static void
     display_hex(unsigned length, uint8_t *data)
     {
       unsigned i;
     
       for (i = 0; i&lt;length; i++)
         printf("%02x ", data[i]);
     
       printf("\n");
     }
     
     int
     main(int argc, char **argv)
     {
       struct sha1_ctx ctx;
       uint8_t buffer[BUF_SIZE];
       uint8_t digest[SHA1_DIGEST_SIZE];
       
       sha1_init(&amp;ctx);
       for (;;)
       {
         int done = fread(buffer, 1, sizeof(buffer), stdin);
         sha1_update(&amp;ctx, done, buffer);
         if (done &lt; sizeof(buffer))
           break;
       }
       if (ferror(stdin))
         return EXIT_FAILURE;
     
       sha1_digest(&amp;ctx, SHA1_DIGEST_SIZE, digest);
     
       display_hex(SHA1_DIGEST_SIZE, digest);
       return EXIT_SUCCESS;  
     }
</pre></pre>
   <p>On a typical Unix system, this program can be compiled and linked with
the command line
<pre class="example">     cc sha-example.c -o sha-example -lnettle
</pre>
   <div class="node">
<a name="Linking"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Reference">Reference</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Example">Example</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">5 Linking</h2>

<p>Nettle actually consists of two libraries, <samp><span class="file">libnettle</span></samp> and
<samp><span class="file">libhogweed</span></samp>. The <samp><span class="file">libhogweed</span></samp> library contains those
functions of Nettle that uses bignum operations, and depends on the GMP
library. With this division, linking works the same for both static and
dynamic libraries.

   <p>If an application uses only the symmetric crypto algorithms of Nettle
(i.e., block ciphers, hash functions, and the like), it's sufficient to
link with <code>-lnettle</code>. If an application also uses public-key
algorithms, the recommended linker flags are <code>-lhogweed -lnettle
-lgmp</code>. If the involved libraries are installed as dynamic libraries, it
may be sufficient to link with just <code>-lhogweed</code>, and the loader
will resolve the dependencies automatically.

<div class="node">
<a name="Reference"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Nettle-soup">Nettle soup</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Linking">Linking</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">6 Reference</h2>

<p>This chapter describes all the Nettle functions, grouped by family.

<ul class="menu">
<li><a accesskey="1" href="#Hash-functions">Hash functions</a>
<li><a accesskey="2" href="#Cipher-functions">Cipher functions</a>
<li><a accesskey="3" href="#Cipher-modes">Cipher modes</a>
<li><a accesskey="4" href="#Keyed-hash-functions">Keyed hash functions</a>
<li><a accesskey="5" href="#Public_002dkey-algorithms">Public-key algorithms</a>
<li><a accesskey="6" href="#Randomness">Randomness</a>
<li><a accesskey="7" href="#Miscellaneous-functions">Miscellaneous functions</a>
<li><a accesskey="8" href="#Compatibility-functions">Compatibility functions</a>
</ul>

<div class="node">
<a name="Hash-functions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Cipher-functions">Cipher functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Reference">Reference</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reference">Reference</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">6.1 Hash functions</h3>

<p><a name="index-Hash-function-1"></a>A cryptographic <dfn>hash function</dfn> is a function that takes variable
size strings, and maps them to strings of fixed, short, length. There
are naturally lots of collisions, as there are more possible 1MB files
than 20 byte strings. But the function is constructed such that is hard
to find the collisions. More precisely, a cryptographic hash function
<code>H</code> should have the following properties:

     <dl>
<dt><em>One-way</em><dd><a name="index-One_002dway-2"></a>Given a hash value <code>H(x)</code> it is hard to find a string <code>x</code>
that hashes to that value.

     <br><dt><em>Collision-resistant</em><dd><a name="index-Collision_002dresistant-3"></a>It is hard to find two different strings, <code>x</code> and <code>y</code>, such
that <code>H(x)</code> = <code>H(y)</code>.

   </dl>

   <p>Hash functions are useful as building blocks for digital signatures,
message authentication codes, pseudo random generators, association of
unique ids to documents, and many other things.

   <p>The most commonly used hash functions are MD5 and SHA1. Unfortunately,
both these fail the collision-resistance requirement; cryptologists have
found ways to construct colliding inputs. The recommended hash function
for new applications is SHA256, even though it uses a structure similar
to MD5 and SHA1. Constructing better hash functions is an urgent research
problem.

<h4 class="subsection">6.1.1 <acronym>MD5</acronym></h4>

<p>MD5 is a message digest function constructed by Ronald Rivest, and
described in <cite>RFC 1321</cite>. It outputs message digests of 128 bits, or
16 octets. Nettle defines MD5 in <samp><span class="file">&lt;nettle/md5.h&gt;</span></samp>.

<div class="defun">
&mdash; Context struct: <b>struct md5_ctx</b><var><a name="index-struct-md5_005fctx-4"></a></var><br>
        </div>

<div class="defun">
&mdash; Constant: <b>MD5_DIGEST_SIZE</b><var><a name="index-MD5_005fDIGEST_005fSIZE-5"></a></var><br>
<blockquote><p>The size of an MD5 digest, i.e. 16. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>MD5_DATA_SIZE</b><var><a name="index-MD5_005fDATA_005fSIZE-6"></a></var><br>
<blockquote><p>The internal block size of MD5. Useful for some special constructions,
in particular HMAC-MD5. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>md5_init</b> (<var>struct md5_ctx *ctx</var>)<var><a name="index-md5_005finit-7"></a></var><br>
<blockquote><p>Initialize the MD5 state. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>md5_update</b> (<var>struct md5_ctx *ctx, unsigned length, const uint8_t *data</var>)<var><a name="index-md5_005fupdate-8"></a></var><br>
<blockquote><p>Hash some more data. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>md5_digest</b> (<var>struct md5_ctx *ctx, unsigned length, uint8_t *digest</var>)<var><a name="index-md5_005fdigest-9"></a></var><br>
<blockquote><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>MD5_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.

        <p>This function also resets the context in the same way as
<code>md5_init</code>. 
</p></blockquote></div>

   <p>The normal way to use MD5 is to call the functions in order: First
<code>md5_init</code>, then <code>md5_update</code> zero or more times, and finally
<code>md5_digest</code>. After <code>md5_digest</code>, the context is reset to
its initial state, so you can start over calling <code>md5_update</code> to
hash new data.

   <p>To start over, you can call <code>md5_init</code> at any time.

<h4 class="subsection">6.1.2 <acronym>MD2</acronym></h4>

<p>MD2 is another hash function of Ronald Rivest's, described in
<cite>RFC 1319</cite>. It outputs message digests of 128 bits, or 16 octets. 
Nettle defines MD2 in <samp><span class="file">&lt;nettle/md2.h&gt;</span></samp>.

<div class="defun">
&mdash; Context struct: <b>struct md2_ctx</b><var><a name="index-struct-md2_005fctx-10"></a></var><br>
        </div>

<div class="defun">
&mdash; Constant: <b>MD2_DIGEST_SIZE</b><var><a name="index-MD2_005fDIGEST_005fSIZE-11"></a></var><br>
<blockquote><p>The size of an MD2 digest, i.e. 16. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>MD2_DATA_SIZE</b><var><a name="index-MD2_005fDATA_005fSIZE-12"></a></var><br>
<blockquote><p>The internal block size of MD2. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>md2_init</b> (<var>struct md2_ctx *ctx</var>)<var><a name="index-md2_005finit-13"></a></var><br>
<blockquote><p>Initialize the MD2 state. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>md2_update</b> (<var>struct md2_ctx *ctx, unsigned length, const uint8_t *data</var>)<var><a name="index-md2_005fupdate-14"></a></var><br>
<blockquote><p>Hash some more data. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>md2_digest</b> (<var>struct md2_ctx *ctx, unsigned length, uint8_t *digest</var>)<var><a name="index-md2_005fdigest-15"></a></var><br>
<blockquote><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>MD2_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.

        <p>This function also resets the context in the same way as
<code>md2_init</code>. 
</p></blockquote></div>

<h4 class="subsection">6.1.3 <acronym>MD4</acronym></h4>

<p>MD4 is a predecessor of MD5, described in <cite>RFC 1320</cite>. Like MD5, it
is constructed by Ronald Rivest. It outputs message digests of 128 bits,
or 16 octets. Nettle defines MD4 in <samp><span class="file">&lt;nettle/md4.h&gt;</span></samp>. Use of MD4 is
not recommended, but it is sometimes needed for compatibility with
existing applications and protocols.

<div class="defun">
&mdash; Context struct: <b>struct md4_ctx</b><var><a name="index-struct-md4_005fctx-16"></a></var><br>
        </div>

<div class="defun">
&mdash; Constant: <b>MD4_DIGEST_SIZE</b><var><a name="index-MD4_005fDIGEST_005fSIZE-17"></a></var><br>
<blockquote><p>The size of an MD4 digest, i.e. 16. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>MD4_DATA_SIZE</b><var><a name="index-MD4_005fDATA_005fSIZE-18"></a></var><br>
<blockquote><p>The internal block size of MD4. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>md4_init</b> (<var>struct md4_ctx *ctx</var>)<var><a name="index-md4_005finit-19"></a></var><br>
<blockquote><p>Initialize the MD4 state. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>md4_update</b> (<var>struct md4_ctx *ctx, unsigned length, const uint8_t *data</var>)<var><a name="index-md4_005fupdate-20"></a></var><br>
<blockquote><p>Hash some more data. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>md4_digest</b> (<var>struct md4_ctx *ctx, unsigned length, uint8_t *digest</var>)<var><a name="index-md4_005fdigest-21"></a></var><br>
<blockquote><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>MD4_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.

        <p>This function also resets the context in the same way as
<code>md4_init</code>. 
</p></blockquote></div>

<h4 class="subsection">6.1.4 <acronym>RIPEMD160</acronym></h4>

<p>RIPEMD160 is a hash function designed by Hans Dobbertin, Antoon
Bosselaers, and Bart Preneel, as a strengthened version of RIPEMD
(which, like MD4 and MD5, fails the collision-resistance requirement). 
It produces message digests of 160 bits, or 20 octets. Nettle defined
RIPEMD160 in <samp><span class="file">nettle/ripemd160.h</span></samp>.

<div class="defun">
&mdash; Context struct: <b>struct ripemd160_ctx</b><var><a name="index-struct-ripemd160_005fctx-22"></a></var><br>
        </div>

<div class="defun">
&mdash; Constant: <b>RIPEMD160_DIGEST_SIZE</b><var><a name="index-RIPEMD160_005fDIGEST_005fSIZE-23"></a></var><br>
<blockquote><p>The size of an RIPEMD160 digest, i.e. 20. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>RIPEMD160_DATA_SIZE</b><var><a name="index-RIPEMD160_005fDATA_005fSIZE-24"></a></var><br>
<blockquote><p>The internal block size of RIPEMD160. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>ripemd160_init</b> (<var>struct ripemd160_ctx *ctx</var>)<var><a name="index-ripemd160_005finit-25"></a></var><br>
<blockquote><p>Initialize the RIPEMD160 state. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>ripemd160_update</b> (<var>struct ripemd160_ctx *ctx, unsigned length, const uint8_t *data</var>)<var><a name="index-ripemd160_005fupdate-26"></a></var><br>
<blockquote><p>Hash some more data. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>ripemd160_digest</b> (<var>struct ripemd160_ctx *ctx, unsigned length, uint8_t *digest</var>)<var><a name="index-ripemd160_005fdigest-27"></a></var><br>
<blockquote><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>RIPEMD160_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.

        <p>This function also resets the context in the same way as
<code>ripemd160_init</code>. 
</p></blockquote></div>

<h4 class="subsection">6.1.5 <acronym>SHA1</acronym></h4>

<p>SHA1 is a hash function specified by <dfn>NIST</dfn> (The U.S. National Institute
for Standards and Technology). It outputs hash values of 160 bits, or 20
octets. Nettle defines SHA1 in <samp><span class="file">&lt;nettle/sha.h&gt;</span></samp>.

   <p>The functions are analogous to the MD5 ones.

<div class="defun">
&mdash; Context struct: <b>struct sha1_ctx</b><var><a name="index-struct-sha1_005fctx-28"></a></var><br>
        </div>

<div class="defun">
&mdash; Constant: <b>SHA1_DIGEST_SIZE</b><var><a name="index-SHA1_005fDIGEST_005fSIZE-29"></a></var><br>
<blockquote><p>The size of an SHA1 digest, i.e. 20. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>SHA1_DATA_SIZE</b><var><a name="index-SHA1_005fDATA_005fSIZE-30"></a></var><br>
<blockquote><p>The internal block size of SHA1. Useful for some special constructions,
in particular HMAC-SHA1. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>sha1_init</b> (<var>struct sha1_ctx *ctx</var>)<var><a name="index-sha1_005finit-31"></a></var><br>
<blockquote><p>Initialize the SHA1 state. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>sha1_update</b> (<var>struct sha1_ctx *ctx, unsigned length, const uint8_t *data</var>)<var><a name="index-sha1_005fupdate-32"></a></var><br>
<blockquote><p>Hash some more data. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>sha1_digest</b> (<var>struct sha1_ctx *ctx, unsigned length, uint8_t *digest</var>)<var><a name="index-sha1_005fdigest-33"></a></var><br>
<blockquote><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>SHA1_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.

        <p>This function also resets the context in the same way as
<code>sha1_init</code>. 
</p></blockquote></div>

<h4 class="subsection">6.1.6 <acronym>SHA256</acronym></h4>

<p>SHA256 is another hash function specified by <dfn>NIST</dfn>, intended as a
replacement for <acronym>SHA1</acronym>, generating larger digests. It outputs
hash values of 256 bits, or 32 octets. Nettle defines SHA256 in
<samp><span class="file">&lt;nettle/sha.h&gt;</span></samp>.

   <p>The functions are analogous to the MD5 ones.

<div class="defun">
&mdash; Context struct: <b>struct sha256_ctx</b><var><a name="index-struct-sha256_005fctx-34"></a></var><br>
        </div>

<div class="defun">
&mdash; Constant: <b>SHA256_DIGEST_SIZE</b><var><a name="index-SHA256_005fDIGEST_005fSIZE-35"></a></var><br>
<blockquote><p>The size of an SHA256 digest, i.e. 32. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>SHA256_DATA_SIZE</b><var><a name="index-SHA256_005fDATA_005fSIZE-36"></a></var><br>
<blockquote><p>The internal block size of SHA256. Useful for some special constructions,
in particular HMAC-SHA256. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>sha256_init</b> (<var>struct sha256_ctx *ctx</var>)<var><a name="index-sha256_005finit-37"></a></var><br>
<blockquote><p>Initialize the SHA256 state. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>sha256_update</b> (<var>struct sha256_ctx *ctx, unsigned length, const uint8_t *data</var>)<var><a name="index-sha256_005fupdate-38"></a></var><br>
<blockquote><p>Hash some more data. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>sha256_digest</b> (<var>struct sha256_ctx *ctx, unsigned length, uint8_t *digest</var>)<var><a name="index-sha256_005fdigest-39"></a></var><br>
<blockquote><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>SHA256_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.

        <p>This function also resets the context in the same way as
<code>sha256_init</code>. 
</p></blockquote></div>

<h4 class="subsection">6.1.7 <acronym>SHA224</acronym></h4>

<p>SHA224 is a variant of SHA256, with a different initial state, and with
the output truncated to 224 bits, or 28 octets. Nettle defines SHA224 in
<samp><span class="file">&lt;nettle/sha.h&gt;</span></samp>.

   <p>The functions are analogous to the MD5 ones.

<div class="defun">
&mdash; Context struct: <b>struct sha224_ctx</b><var><a name="index-struct-sha224_005fctx-40"></a></var><br>
        </div>

<div class="defun">
&mdash; Constant: <b>SHA224_DIGEST_SIZE</b><var><a name="index-SHA224_005fDIGEST_005fSIZE-41"></a></var><br>
<blockquote><p>The size of an SHA224 digest, i.e. 28. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>SHA224_DATA_SIZE</b><var><a name="index-SHA224_005fDATA_005fSIZE-42"></a></var><br>
<blockquote><p>The internal block size of SHA224. Useful for some special constructions,
in particular HMAC-SHA224. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>sha224_init</b> (<var>struct sha224_ctx *ctx</var>)<var><a name="index-sha224_005finit-43"></a></var><br>
<blockquote><p>Initialize the SHA224 state. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>sha224_update</b> (<var>struct sha224_ctx *ctx, unsigned length, const uint8_t *data</var>)<var><a name="index-sha224_005fupdate-44"></a></var><br>
<blockquote><p>Hash some more data. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>sha224_digest</b> (<var>struct sha224_ctx *ctx, unsigned length, uint8_t *digest</var>)<var><a name="index-sha224_005fdigest-45"></a></var><br>
<blockquote><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>SHA224_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.

        <p>This function also resets the context in the same way as
<code>sha224_init</code>. 
</p></blockquote></div>

<h4 class="subsection">6.1.8 <acronym>SHA512</acronym></h4>

<p>SHA512 is a larger sibling to SHA256, with a very similar structure but
with both the output and the internal variables of twice the size. The
internal variables are 64 bits rather than 32, making it significantly
slower on 32-bit computers. It outputs hash values of 512 bits, or 64
octets. Nettle defines SHA512 in <samp><span class="file">&lt;nettle/sha.h&gt;</span></samp>.

   <p>The functions are analogous to the MD5 ones.

<div class="defun">
&mdash; Context struct: <b>struct sha512_ctx</b><var><a name="index-struct-sha512_005fctx-46"></a></var><br>
        </div>

<div class="defun">
&mdash; Constant: <b>SHA512_DIGEST_SIZE</b><var><a name="index-SHA512_005fDIGEST_005fSIZE-47"></a></var><br>
<blockquote><p>The size of an SHA512 digest, i.e. 64. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>SHA512_DATA_SIZE</b><var><a name="index-SHA512_005fDATA_005fSIZE-48"></a></var><br>
<blockquote><p>The internal block size of SHA512. Useful for some special constructions,
in particular HMAC-SHA512. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>sha512_init</b> (<var>struct sha512_ctx *ctx</var>)<var><a name="index-sha512_005finit-49"></a></var><br>
<blockquote><p>Initialize the SHA512 state. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>sha512_update</b> (<var>struct sha512_ctx *ctx, unsigned length, const uint8_t *data</var>)<var><a name="index-sha512_005fupdate-50"></a></var><br>
<blockquote><p>Hash some more data. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>sha512_digest</b> (<var>struct sha512_ctx *ctx, unsigned length, uint8_t *digest</var>)<var><a name="index-sha512_005fdigest-51"></a></var><br>
<blockquote><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>SHA512_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.

        <p>This function also resets the context in the same way as
<code>sha512_init</code>. 
</p></blockquote></div>

<h4 class="subsection">6.1.9 <acronym>SHA384</acronym></h4>

<p>SHA384 is a variant of SHA512, with a different initial state, and with
the output truncated to 384 bits, or 48 octets. Nettle defines SHA384 in
<samp><span class="file">&lt;nettle/sha.h&gt;</span></samp>.

   <p>The functions are analogous to the MD5 ones.

<div class="defun">
&mdash; Context struct: <b>struct sha384_ctx</b><var><a name="index-struct-sha384_005fctx-52"></a></var><br>
        </div>

<div class="defun">
&mdash; Constant: <b>SHA384_DIGEST_SIZE</b><var><a name="index-SHA384_005fDIGEST_005fSIZE-53"></a></var><br>
<blockquote><p>The size of an SHA384 digest, i.e. 48. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>SHA384_DATA_SIZE</b><var><a name="index-SHA384_005fDATA_005fSIZE-54"></a></var><br>
<blockquote><p>The internal block size of SHA384. Useful for some special constructions,
in particular HMAC-SHA384. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>sha384_init</b> (<var>struct sha384_ctx *ctx</var>)<var><a name="index-sha384_005finit-55"></a></var><br>
<blockquote><p>Initialize the SHA384 state. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>sha384_update</b> (<var>struct sha384_ctx *ctx, unsigned length, const uint8_t *data</var>)<var><a name="index-sha384_005fupdate-56"></a></var><br>
<blockquote><p>Hash some more data. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>sha384_digest</b> (<var>struct sha384_ctx *ctx, unsigned length, uint8_t *digest</var>)<var><a name="index-sha384_005fdigest-57"></a></var><br>
<blockquote><p>Performs final processing and extracts the message digest, writing it
to <var>digest</var>. <var>length</var> may be smaller than
<code>SHA384_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the digest are written.

        <p>This function also resets the context in the same way as
<code>sha384_init</code>. 
</p></blockquote></div>

<h4 class="subsection">6.1.10 <code>struct nettle_hash</code></h4>

<p>Nettle includes a struct including information about the supported hash
functions. It is defined in <samp><span class="file">&lt;nettle/nettle-meta.h&gt;</span></samp>, and is used
by Nettle's implementation of <acronym>HMAC</acronym> (see <a href="#Keyed-hash-functions">Keyed hash functions</a>).

<div class="defun">
&mdash; Meta struct: <code>struct nettle_hash</code><var> name context_size digest_size block_size init update digest<a name="index-g_t_0040code_007bstruct-nettle_005fhash_007d-58"></a></var><br>
<blockquote><p>The last three attributes are function pointers, of types
<code>nettle_hash_init_func</code>, <code>nettle_hash_update_func</code>, and
<code>nettle_hash_digest_func</code>. The first argument to these functions is
<code>void *</code> pointer to a context struct, which is of size
<code>context_size</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant Struct: struct nettle_hash <b>nettle_md2</b><var><a name="index-nettle_005fmd2-59"></a></var><br>
&mdash; Constant Struct: struct nettle_hash <b>nettle_md4</b><var><a name="index-nettle_005fmd4-60"></a></var><br>
&mdash; Constant Struct: struct nettle_hash <b>nettle_md5</b><var><a name="index-nettle_005fmd5-61"></a></var><br>
&mdash; Constant Struct: struct nettle_hash <b>nettle_ripemd160</b><var><a name="index-nettle_005fripemd160-62"></a></var><br>
&mdash; Constant Struct: struct nettle_hash <b>nettle_sha1</b><var><a name="index-nettle_005fsha1-63"></a></var><br>
&mdash; Constant Struct: struct nettle_hash <b>nettle_sha224</b><var><a name="index-nettle_005fsha224-64"></a></var><br>
&mdash; Constant Struct: struct nettle_hash <b>nettle_sha256</b><var><a name="index-nettle_005fsha256-65"></a></var><br>
&mdash; Constant Struct: struct nettle_hash <b>nettle_sha384</b><var><a name="index-nettle_005fsha384-66"></a></var><br>
&mdash; Constant Struct: struct nettle_hash <b>nettle_sha512</b><var><a name="index-nettle_005fsha512-67"></a></var><br>
<blockquote>
        <p>These are all the hash functions that Nettle implements.

        <p>Nettle also exports a list of all these hashes.  This list can be used
to dynamically enumerate or search the supported algorithms:

   &mdash; Constant Struct: struct nettle_hash ** <b>nettle_hashes</b><var><a name="index-nettle_005fhashes-68"></a></var><br>

        </div>

<div class="node">
<a name="Cipher-functions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Cipher-modes">Cipher modes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Hash-functions">Hash functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reference">Reference</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">6.2 Cipher functions</h3>

<p><a name="index-Cipher-69"></a>
A <dfn>cipher</dfn> is a function that takes a message or <dfn>plaintext</dfn>
and a secret <dfn>key</dfn> and transforms it to a <dfn>ciphertext</dfn>. Given
only the ciphertext, but not the key, it should be hard to find the
plaintext. Given matching pairs of plaintext and ciphertext, it should
be hard to find the key.

   <p><a name="index-Block-Cipher-70"></a><a name="index-Stream-Cipher-71"></a>
There are two main classes of ciphers: Block ciphers and stream ciphers.

   <p>A block cipher can process data only in fixed size chunks, called
<dfn>blocks</dfn>. Typical block sizes are 8 or 16 octets. To encrypt
arbitrary messages, you usually have to pad it to an integral number of
blocks, split it into blocks, and then process each block. The simplest
way is to process one block at a time, independent of each other. That
mode of operation is called <dfn>ECB</dfn>, Electronic Code Book mode. 
However, using <acronym>ECB</acronym> is usually a bad idea. For a start, plaintext blocks
that are equal are transformed to ciphertext blocks that are equal; that
leaks information about the plaintext. Usually you should apply the
cipher is some &ldquo;feedback mode&rdquo;, <dfn>CBC</dfn> (Cipher Block Chaining) and
<dfn>CTR</dfn> (Counter mode) being two of
of the most popular. See See <a href="#Cipher-modes">Cipher modes</a>, for information on
how to apply <acronym>CBC</acronym> and <acronym>CTR</acronym> with Nettle.

   <p>A stream cipher can be used for messages of arbitrary length. A typical
stream cipher is a keyed pseudo-random generator. To encrypt a plaintext
message of <var>n</var> octets, you key the generator, generate <var>n</var>
octets of pseudo-random data, and XOR it with the plaintext. To decrypt,
regenerate the same stream using the key, XOR it to the ciphertext, and
the plaintext is recovered.

   <p><strong>Caution:</strong> The first rule for this kind of cipher is the
same as for a One Time Pad: <em>never</em> ever use the same key twice.

   <p>A common misconception is that encryption, by itself, implies
authentication. Say that you and a friend share a secret key, and you
receive an encrypted message. You apply the key, and get a plaintext
message that makes sense to you. Can you then be sure that it really was
your friend that wrote the message you're reading? The answer is no. For
example, if you were using a block cipher in ECB mode, an attacker may
pick up the message on its way, and reorder, delete or repeat some of
the blocks. Even if the attacker can't decrypt the message, he can
change it so that you are not reading the same message as your friend
wrote. If you are using a block cipher in <acronym>CBC</acronym> mode rather than
ECB, or are using a stream cipher, the possibilities for this sort of
attack are different, but the attacker can still make predictable
changes to the message.

   <p>It is recommended to <em>always</em> use an authentication mechanism in
addition to encrypting the messages. Popular choices are Message
Authentication Codes like <acronym>HMAC-SHA1</acronym> (see <a href="#Keyed-hash-functions">Keyed hash functions</a>), or digital signatures like <acronym>RSA</acronym>.

   <p>Some ciphers have so called &ldquo;weak keys&rdquo;, keys that results in
undesirable structure after the key setup processing, and should be
avoided. In Nettle, most key setup functions have no return value, but
for ciphers with weak keys, the return value indicates whether or not
the given key is weak. For good keys, key setup returns 1, and for weak
keys, it returns 0. When possible, avoid algorithms that
have weak keys. There are several good ciphers that don't have any weak
keys.

   <p>To encrypt a message, you first initialize a cipher context for
encryption or decryption with a particular key. You then use the context
to process plaintext or ciphertext messages. The initialization is known
as <dfn>key setup</dfn>. With Nettle, it is recommended to use each
context struct for only one direction, even if some of the ciphers use a
single key setup function that can be used for both encryption and
decryption.

<h4 class="subsection">6.2.1 AES</h4>

<p>AES is a block cipher, specified by NIST as a replacement for
the older DES standard. The standard is the result of a competition
between cipher designers. The winning design, also known as RIJNDAEL,
was constructed by Joan Daemen and Vincent Rijnmen.

   <p>Like all the AES candidates, the winning design uses a block size of 128
bits, or 16 octets, and variable key-size, 128, 192 and 256 bits (16, 24
and 32 octets) being the allowed key sizes. It does not have any weak
keys. Nettle defines AES in <samp><span class="file">&lt;nettle/aes.h&gt;</span></samp>.

<div class="defun">
&mdash; Context struct: <b>struct aes_ctx</b><var><a name="index-struct-aes_005fctx-72"></a></var><br>
        </div>

<div class="defun">
&mdash; Constant: <b>AES_BLOCK_SIZE</b><var><a name="index-AES_005fBLOCK_005fSIZE-73"></a></var><br>
<blockquote><p>The AES block-size, 16
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>AES_MIN_KEY_SIZE</b><var><a name="index-AES_005fMIN_005fKEY_005fSIZE-74"></a></var><br>
        </div>

<div class="defun">
&mdash; Constant: <b>AES_MAX_KEY_SIZE</b><var><a name="index-AES_005fMAX_005fKEY_005fSIZE-75"></a></var><br>
        </div>

<div class="defun">
&mdash; Constant: <b>AES_KEY_SIZE</b><var><a name="index-AES_005fKEY_005fSIZE-76"></a></var><br>
<blockquote><p>Default AES key size, 32
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>aes_set_encrypt_key</b> (<var>struct aes_ctx *ctx, unsigned length, const uint8_t *key</var>)<var><a name="index-aes_005fset_005fencrypt_005fkey-77"></a></var><br>
&mdash; Function: void <b>aes_set_decrypt_key</b> (<var>struct aes_ctx *ctx, unsigned length, const uint8_t *key</var>)<var><a name="index-aes_005fset_005fdecrypt_005fkey-78"></a></var><br>
<blockquote><p>Initialize the cipher, for encryption or decryption, respectively. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>aes_invert_key</b> (<var>struct aes_ctx *dst, const struct aes_ctx *src</var>)<var><a name="index-aes_005finvert_005fkey-79"></a></var><br>
<blockquote><p>Given a context <var>src</var> initialized for encryption, initializes the
context struct <var>dst</var> for decryption, using the same key. If the same
context struct is passed for both <code>src</code> and <code>dst</code>, it is
converted in place. Calling <code>aes_set_encrypt_key</code> and
<code>aes_invert_key</code> is more efficient than calling
<code>aes_set_encrypt_key</code> and <code>aes_set_decrypt_key</code>. This function
is mainly useful for applications which needs to both encrypt and
decrypt using the <em>same</em> key. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>aes_encrypt</b> (<var>struct aes_ctx *ctx, unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-aes_005fencrypt-80"></a></var><br>
<blockquote><p>Encryption function. <var>length</var> must be an integral multiple of the
block size. If it is more than one block, the data is processed in ECB
mode. <code>src</code> and <code>dst</code> may be equal, but they must not overlap
in any other way. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>aes_decrypt</b> (<var>struct aes_ctx *ctx, unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-aes_005fdecrypt-81"></a></var><br>
<blockquote><p>Analogous to <code>aes_encrypt</code>
</p></blockquote></div>

<h4 class="subsection">6.2.2 ARCFOUR</h4>

<p>ARCFOUR is a stream cipher, also known under the trade marked name RC4,
and it is one of the fastest ciphers around. A problem is that the key
setup of ARCFOUR is quite weak, you should never use keys with
structure, keys that are ordinary passwords, or sequences of keys like
&ldquo;secret:1&rdquo;, &ldquo;secret:2&rdquo;, <small class="enddots">...</small>. If you have keys that don't look
like random bit strings, and you want to use ARCFOUR, always hash the
key before feeding it to ARCFOUR. Furthermore, the initial bytes of the
generated key stream leak information about the key; for this reason, it
is recommended to discard the first 512 bytes of the key stream.

<pre class="example">     /* A more robust key setup function for ARCFOUR */
     void
     arcfour_set_key_hashed(struct arcfour_ctx *ctx,
                            unsigned length, const uint8_t *key)
     {
       struct sha256_ctx hash;
       uint8_t digest[SHA256_DIGEST_SIZE];
       uint8_t buffer[0x200];
     
       sha256_init(&amp;hash);
       sha256_update(&amp;hash, length, key);
       sha256_digest(&amp;hash, SHA256_DIGEST_SIZE, digest);
     
       arcfour_set_key(ctx, SHA256_DIGEST_SIZE, digest);
       arcfour_crypt(ctx, sizeof(buffer), buffer, buffer);
     }
</pre>
   <p>Nettle defines ARCFOUR in <samp><span class="file">&lt;nettle/arcfour.h&gt;</span></samp>.

<div class="defun">
&mdash; Context struct: <b>struct arcfour_ctx</b><var><a name="index-struct-arcfour_005fctx-82"></a></var><br>
        </div>

<div class="defun">
&mdash; Constant: <b>ARCFOUR_MIN_KEY_SIZE</b><var><a name="index-ARCFOUR_005fMIN_005fKEY_005fSIZE-83"></a></var><br>
<blockquote><p>Minimum key size, 1
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>ARCFOUR_MAX_KEY_SIZE</b><var><a name="index-ARCFOUR_005fMAX_005fKEY_005fSIZE-84"></a></var><br>
<blockquote><p>Maximum key size, 256
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>ARCFOUR_KEY_SIZE</b><var><a name="index-ARCFOUR_005fKEY_005fSIZE-85"></a></var><br>
<blockquote><p>Default ARCFOUR key size, 16
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>arcfour_set_key</b> (<var>struct arcfour_ctx *ctx, unsigned length, const uint8_t *key</var>)<var><a name="index-arcfour_005fset_005fkey-86"></a></var><br>
<blockquote><p>Initialize the cipher. The same function is used for both encryption and
decryption. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>arcfour_crypt</b> (<var>struct arcfour_ctx *ctx, unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-arcfour_005fcrypt-87"></a></var><br>
<blockquote><p>Encrypt some data. The same function is used for both encryption and
decryption. Unlike the block ciphers, this function modifies the
context, so you can split the data into arbitrary chunks and encrypt
them one after another. The result is the same as if you had called
<code>arcfour_crypt</code> only once with all the data. 
</p></blockquote></div>

<h4 class="subsection">6.2.3 ARCTWO</h4>

<p>ARCTWO (also known as the trade marked name RC2) is a block cipher
specified in RFC 2268. Nettle also include a variation of the ARCTWO
set key operation that lack one step, to be compatible with the
reverse engineered RC2 cipher description, as described in a Usenet
post to <code>sci.crypt</code> by Peter Gutmann.

   <p>ARCTWO uses a block size of 64 bits, and variable key-size ranging
from 1 to 128 octets. Besides the key, ARCTWO also has a second
parameter to key setup, the number of effective key bits, <code>ekb</code>. 
This parameter can be used to artificially reduce the key size. In
practice, <code>ekb</code> is usually set equal to the input key size. 
Nettle defines ARCTWO in <samp><span class="file">&lt;nettle/arctwo.h&gt;</span></samp>.

   <p>We do not recommend the use of ARCTWO; the Nettle implementation is
provided primarily for interoperability with existing applications and
standards.

<div class="defun">
&mdash; Context struct: <b>struct arctwo_ctx</b><var><a name="index-struct-arctwo_005fctx-88"></a></var><br>
        </div>

<div class="defun">
&mdash; Constant: <b>ARCTWO_BLOCK_SIZE</b><var><a name="index-ARCTWO_005fBLOCK_005fSIZE-89"></a></var><br>
<blockquote><p>The ARCTWO block-size, 8
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>ARCTWO_MIN_KEY_SIZE</b><var><a name="index-ARCTWO_005fMIN_005fKEY_005fSIZE-90"></a></var><br>
        </div>

<div class="defun">
&mdash; Constant: <b>ARCTWO_MAX_KEY_SIZE</b><var><a name="index-ARCTWO_005fMAX_005fKEY_005fSIZE-91"></a></var><br>
        </div>

<div class="defun">
&mdash; Constant: <b>ARCTWO_KEY_SIZE</b><var><a name="index-ARCTWO_005fKEY_005fSIZE-92"></a></var><br>
<blockquote><p>Default ARCTWO key size, 8
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>arctwo_set_key_ekb</b> (<var>struct arctwo_ctx *ctx, unsigned length, const uint8_t *key, unsigned ekb</var>)<var><a name="index-arctwo_005fset_005fkey_005fekb-93"></a></var><br>
&mdash; Function: void <b>arctwo_set_key</b> (<var>struct arctwo_ctx *ctx, unsigned length, const uint8_t *key</var>)<var><a name="index-arctwo_005fset_005fkey-94"></a></var><br>
&mdash; Function: void <b>arctwo_set_key_gutmann</b> (<var>struct arctwo_ctx *ctx, unsigned length, const uint8_t *key</var>)<var><a name="index-arctwo_005fset_005fkey_005fgutmann-95"></a></var><br>
<blockquote><p>Initialize the cipher. The same function is used for both encryption
and decryption. The first function is the most general one, which lets
you provide both the variable size key, and the desired effective key
size (in bits). The maximum value for <var>ekb</var> is 1024, and for
convenience, <code>ekb = 0</code> has the same effect as <code>ekb = 1024</code>.

        <p><code>arctwo_set_key(ctx, length, key)</code> is equivalent to
<code>arctwo_set_key_ekb(ctx, length, key, 8*length)</code>, and
<code>arctwo_set_key_gutmann(ctx, length, key)</code> is equivalent to
<code>arctwo_set_key_ekb(ctx, length, key, 1024)</code>
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>arctwo_encrypt</b> (<var>struct arctwo_ctx *ctx, unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-arctwo_005fencrypt-96"></a></var><br>
<blockquote><p>Encryption function. <var>length</var> must be an integral multiple of the
block size. If it is more than one block, the data is processed in ECB
mode. <code>src</code> and <code>dst</code> may be equal, but they must not
overlap in any other way. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>arctwo_decrypt</b> (<var>struct arctwo_ctx *ctx, unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-arctwo_005fdecrypt-97"></a></var><br>
<blockquote><p>Analogous to <code>arctwo_encrypt</code>
</p></blockquote></div>

<h4 class="subsection">6.2.4 BLOWFISH</h4>

<p>BLOWFISH is a block cipher designed by Bruce Schneier. It uses a block
size of 64 bits (8 octets), and a variable key size, up to 448 bits. It
has some weak keys. Nettle defines BLOWFISH in <samp><span class="file">&lt;nettle/blowfish.h&gt;</span></samp>.

<div class="defun">
&mdash; Context struct: <b>struct blowfish_ctx</b><var><a name="index-struct-blowfish_005fctx-98"></a></var><br>
        </div>

<div class="defun">
&mdash; Constant: <b>BLOWFISH_BLOCK_SIZE</b><var><a name="index-BLOWFISH_005fBLOCK_005fSIZE-99"></a></var><br>
<blockquote><p>The BLOWFISH block-size, 8
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>BLOWFISH_MIN_KEY_SIZE</b><var><a name="index-BLOWFISH_005fMIN_005fKEY_005fSIZE-100"></a></var><br>
<blockquote><p>Minimum BLOWFISH key size, 8
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>BLOWFISH_MAX_KEY_SIZE</b><var><a name="index-BLOWFISH_005fMAX_005fKEY_005fSIZE-101"></a></var><br>
<blockquote><p>Maximum BLOWFISH key size, 56
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>BLOWFISH_KEY_SIZE</b><var><a name="index-BLOWFISH_005fKEY_005fSIZE-102"></a></var><br>
<blockquote><p>Default BLOWFISH key size, 16
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>blowfish_set_key</b> (<var>struct blowfish_ctx *ctx, unsigned length, const uint8_t *key</var>)<var><a name="index-blowfish_005fset_005fkey-103"></a></var><br>
<blockquote><p>Initialize the cipher. The same function is used for both encryption and
decryption. Checks for weak keys, returning 1
for good keys and 0 for weak keys. Applications that don't care about
weak keys can ignore the return value.

        <p><code>blowfish_encrypt</code> or <code>blowfish_decrypt</code> with a weak key will
crash with an assert violation. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>blowfish_encrypt</b> (<var>struct blowfish_ctx *ctx, unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-blowfish_005fencrypt-104"></a></var><br>
<blockquote><p>Encryption function. <var>length</var> must be an integral multiple of the
block size. If it is more than one block, the data is processed in ECB
mode. <code>src</code> and <code>dst</code> may be equal, but they must not overlap
in any other way. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>blowfish_decrypt</b> (<var>struct blowfish_ctx *ctx, unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-blowfish_005fdecrypt-105"></a></var><br>
<blockquote><p>Analogous to <code>blowfish_encrypt</code>
</p></blockquote></div>

<h4 class="subsection">6.2.5 Camellia</h4>

<p>Camellia is a block cipher developed by Mitsubishi and Nippon Telegraph
and Telephone Corporation, described in <cite>RFC3713</cite>, and recommended
by some Japanese and European authorities as an alternative to AES. The
algorithm is patented. The implementation in Nettle is derived from the
implementation released by NTT under the GNU LGPL (v2.1 or later), and
relies on the implicit patent license of the LGPL. There is also a
statement of royalty-free licensing for Camellia at
<a href="http://www.ntt.co.jp/news/news01e/0104/010417.html">http://www.ntt.co.jp/news/news01e/0104/010417.html</a>, but this
statement has some limitations which seem problematic for free software.

   <p>Camellia uses a the same block size and key sizes as AES: The block size
is 128 bits (16 octets), and the supported key sizes are 128, 192, and
256 bits. Nettle defines Camellia in <samp><span class="file">&lt;nettle/camellia.h&gt;</span></samp>.

<div class="defun">
&mdash; Context struct: <b>struct camellia_ctx</b><var><a name="index-struct-camellia_005fctx-106"></a></var><br>
        </div>

<div class="defun">
&mdash; Constant: <b>CAMELLIA_BLOCK_SIZE</b><var><a name="index-CAMELLIA_005fBLOCK_005fSIZE-107"></a></var><br>
<blockquote><p>The CAMELLIA block-size, 16
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>CAMELLIA_MIN_KEY_SIZE</b><var><a name="index-CAMELLIA_005fMIN_005fKEY_005fSIZE-108"></a></var><br>
        </div>

<div class="defun">
&mdash; Constant: <b>CAMELLIA_MAX_KEY_SIZE</b><var><a name="index-CAMELLIA_005fMAX_005fKEY_005fSIZE-109"></a></var><br>
        </div>

<div class="defun">
&mdash; Constant: <b>CAMELLIA_KEY_SIZE</b><var><a name="index-CAMELLIA_005fKEY_005fSIZE-110"></a></var><br>
<blockquote><p>Default CAMELLIA key size, 32
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>camellia_set_encrypt_key</b> (<var>struct camellia_ctx *ctx, unsigned length, const uint8_t *key</var>)<var><a name="index-camellia_005fset_005fencrypt_005fkey-111"></a></var><br>
&mdash; Function: void <b>camellia_set_decrypt_key</b> (<var>struct camellia_ctx *ctx, unsigned length, const uint8_t *key</var>)<var><a name="index-camellia_005fset_005fdecrypt_005fkey-112"></a></var><br>
<blockquote><p>Initialize the cipher, for encryption or decryption, respectively. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>camellia_invert_key</b> (<var>struct camellia_ctx *dst, const struct camellia_ctx *src</var>)<var><a name="index-camellia_005finvert_005fkey-113"></a></var><br>
<blockquote><p>Given a context <var>src</var> initialized for encryption, initializes the
context struct <var>dst</var> for decryption, using the same key. If the same
context struct is passed for both <code>src</code> and <code>dst</code>, it is
converted in place. Calling <code>camellia_set_encrypt_key</code> and
<code>camellia_invert_key</code> is more efficient than calling
<code>camellia_set_encrypt_key</code> and <code>camellia_set_decrypt_key</code>. This function
is mainly useful for applications which needs to both encrypt and
decrypt using the <em>same</em> key. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>camellia_crypt</b> (<var>struct camellia_ctx *ctx, unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-camellia_005fcrypt-114"></a></var><br>
<blockquote><p>The same function is used for both encryption and decryption. 
<var>length</var> must be an integral multiple of the block size. If it is
more than one block, the data is processed in ECB mode. <code>src</code> and
<code>dst</code> may be equal, but they must not overlap in any other way. 
</p></blockquote></div>

<h4 class="subsection">6.2.6 CAST128</h4>

<p>CAST-128 is a block cipher, specified in <cite>RFC 2144</cite>. It uses a 64
bit (8 octets) block size, and a variable key size of up to 128 bits. 
Nettle defines cast128 in <samp><span class="file">&lt;nettle/cast128.h&gt;</span></samp>.

<div class="defun">
&mdash; Context struct: <b>struct cast128_ctx</b><var><a name="index-struct-cast128_005fctx-115"></a></var><br>
        </div>

<div class="defun">
&mdash; Constant: <b>CAST128_BLOCK_SIZE</b><var><a name="index-CAST128_005fBLOCK_005fSIZE-116"></a></var><br>
<blockquote><p>The CAST128 block-size, 8
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>CAST128_MIN_KEY_SIZE</b><var><a name="index-CAST128_005fMIN_005fKEY_005fSIZE-117"></a></var><br>
<blockquote><p>Minimum CAST128 key size, 5
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>CAST128_MAX_KEY_SIZE</b><var><a name="index-CAST128_005fMAX_005fKEY_005fSIZE-118"></a></var><br>
<blockquote><p>Maximum CAST128 key size, 16
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>CAST128_KEY_SIZE</b><var><a name="index-CAST128_005fKEY_005fSIZE-119"></a></var><br>
<blockquote><p>Default CAST128 key size, 16
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>cast128_set_key</b> (<var>struct cast128_ctx *ctx, unsigned length, const uint8_t *key</var>)<var><a name="index-cast128_005fset_005fkey-120"></a></var><br>
<blockquote><p>Initialize the cipher. The same function is used for both encryption and
decryption. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>cast128_encrypt</b> (<var>struct cast128_ctx *ctx, unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-cast128_005fencrypt-121"></a></var><br>
<blockquote><p>Encryption function. <var>length</var> must be an integral multiple of the
block size. If it is more than one block, the data is processed in ECB
mode. <code>src</code> and <code>dst</code> may be equal, but they must not overlap
in any other way. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>cast128_decrypt</b> (<var>struct cast128_ctx *ctx, unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-cast128_005fdecrypt-122"></a></var><br>
<blockquote><p>Analogous to <code>cast128_encrypt</code>
</p></blockquote></div>

<h4 class="subsection">6.2.7 DES</h4>

<p>DES is the old Data Encryption Standard, specified by NIST. It uses a
block size of 64 bits (8 octets), and a key size of 56 bits. However,
the key bits are distributed over 8 octets, where the least significant
bit of each octet may be used for parity. A common way to use DES is to
generate 8 random octets in some way, then set the least significant bit
of each octet to get odd parity, and initialize DES with the resulting
key.

   <p>The key size of DES is so small that keys can be found by brute force,
using specialized hardware or lots of ordinary work stations in
parallel. One shouldn't be using plain DES at all today, if one uses
DES at all one should be using &ldquo;triple DES&rdquo;, see DES3 below.

   <p>DES also has some weak keys. Nettle defines DES in <samp><span class="file">&lt;nettle/des.h&gt;</span></samp>.

<div class="defun">
&mdash; Context struct: <b>struct des_ctx</b><var><a name="index-struct-des_005fctx-123"></a></var><br>
        </div>

<div class="defun">
&mdash; Constant: <b>DES_BLOCK_SIZE</b><var><a name="index-DES_005fBLOCK_005fSIZE-124"></a></var><br>
<blockquote><p>The DES block-size, 8
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>DES_KEY_SIZE</b><var><a name="index-DES_005fKEY_005fSIZE-125"></a></var><br>
<blockquote><p>DES key size, 8
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>des_set_key</b> (<var>struct des_ctx *ctx, const uint8_t *key</var>)<var><a name="index-des_005fset_005fkey-126"></a></var><br>
<blockquote><p>Initialize the cipher. The same function is used for both encryption and
decryption. Parity bits are ignored. Checks for weak keys, returning 1
for good keys and 0 for weak keys. Applications that don't care about
weak keys can ignore the return value. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>des_encrypt</b> (<var>struct des_ctx *ctx, unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-des_005fencrypt-127"></a></var><br>
<blockquote><p>Encryption function. <var>length</var> must be an integral multiple of the
block size. If it is more than one block, the data is processed in ECB
mode. <code>src</code> and <code>dst</code> may be equal, but they must not overlap
in any other way. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>des_decrypt</b> (<var>struct des_ctx *ctx, unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-des_005fdecrypt-128"></a></var><br>
<blockquote><p>Analogous to <code>des_encrypt</code>
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>des_check_parity</b> (<var>unsigned length, const uint8_t *key</var>)<var>;<a name="index-des_005fcheck_005fparity-129"></a></var><br>
<blockquote><p>Checks that the given key has correct, odd, parity. Returns 1 for
correct parity, and 0 for bad parity. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>des_fix_parity</b> (<var>unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-des_005ffix_005fparity-130"></a></var><br>
<blockquote><p>Adjusts the parity bits to match DES's requirements. You need this
function if you have created a random-looking string by a key agreement
protocol, and want to use it as a DES key. <var>dst</var> and <var>src</var> may
be equal. 
</p></blockquote></div>

<h4 class="subsection">6.2.8 DES3</h4>

<p>The inadequate key size of DES has already been mentioned. One way to
increase the key size is to pipe together several DES boxes with
independent keys. It turns out that using two DES ciphers is not as
secure as one might think, even if the key size of the combination is a
respectable 112 bits.

   <p>The standard way to increase DES's key size is to use three DES boxes. 
The mode of operation is a little peculiar: the middle DES box is wired
in the reverse direction. To encrypt a block with DES3, you encrypt it
using the first 56 bits of the key, then <em>decrypt</em> it using the
middle 56 bits of the key, and finally encrypt it again using the last
56 bits of the key. This is known as &ldquo;ede&rdquo; triple-DES, for
&ldquo;encrypt-decrypt-encrypt&rdquo;.

   <p>The &ldquo;ede&rdquo; construction provides some backward compatibility, as you get
plain single DES simply by feeding the same key to all three boxes. That
should help keeping down the gate count, and the price, of hardware
circuits implementing both plain DES and DES3.

   <p>DES3 has a key size of 168 bits, but just like plain DES, useless parity
bits are inserted, so that keys are represented as 24 octets (192 bits). 
As a 112 bit key is large enough to make brute force attacks
impractical, some applications uses a &ldquo;two-key&rdquo; variant of triple-DES. 
In this mode, the same key bits are used for the first and the last DES
box in the pipe, while the middle box is keyed independently. The
two-key variant is believed to be secure, i.e. there are no known
attacks significantly better than brute force.

   <p>Naturally, it's simple to implement triple-DES on top of Nettle's DES
functions. Nettle includes an implementation of three-key &ldquo;ede&rdquo;
triple-DES, it is defined in the same place as plain DES,
<samp><span class="file">&lt;nettle/des.h&gt;</span></samp>.

<div class="defun">
&mdash; Context struct: <b>struct des3_ctx</b><var><a name="index-struct-des3_005fctx-131"></a></var><br>
        </div>

<div class="defun">
&mdash; Constant: <b>DES3_BLOCK_SIZE</b><var><a name="index-DES3_005fBLOCK_005fSIZE-132"></a></var><br>
<blockquote><p>The DES3 block-size is the same as DES_BLOCK_SIZE, 8
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>DES3_KEY_SIZE</b><var><a name="index-DES3_005fKEY_005fSIZE-133"></a></var><br>
<blockquote><p>DES key size, 24
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>des3_set_key</b> (<var>struct des3_ctx *ctx, const uint8_t *key</var>)<var><a name="index-des3_005fset_005fkey-134"></a></var><br>
<blockquote><p>Initialize the cipher. The same function is used for both encryption and
decryption. Parity bits are ignored. Checks for weak keys, returning 1
if all three keys are good keys, and 0 if one or more key is weak. 
Applications that don't care about weak keys can ignore the return
value. 
</p></blockquote></div>

   <p>For random-looking strings, you can use <code>des_fix_parity</code> to adjust
the parity bits before calling <code>des3_set_key</code>.

<div class="defun">
&mdash; Function: void <b>des3_encrypt</b> (<var>struct des3_ctx *ctx, unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-des3_005fencrypt-135"></a></var><br>
<blockquote><p>Encryption function. <var>length</var> must be an integral multiple of the
block size. If it is more than one block, the data is processed in ECB
mode. <code>src</code> and <code>dst</code> may be equal, but they must not overlap
in any other way. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>des3_decrypt</b> (<var>struct des3_ctx *ctx, unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-des3_005fdecrypt-136"></a></var><br>
<blockquote><p>Analogous to <code>des_encrypt</code>
</p></blockquote></div>

<h4 class="subsection">6.2.9 SERPENT</h4>

<p>SERPENT is one of the AES finalists, designed by Ross Anderson, Eli
Biham and Lars Knudsen. Thus, the interface and properties are similar
to AES'. One peculiarity is that it is quite pointless to use it with
anything but the maximum key size, smaller keys are just padded to
larger ones. Nettle defines SERPENT in <samp><span class="file">&lt;nettle/serpent.h&gt;</span></samp>.

<div class="defun">
&mdash; Context struct: <b>struct serpent_ctx</b><var><a name="index-struct-serpent_005fctx-137"></a></var><br>
        </div>

<div class="defun">
&mdash; Constant: <b>SERPENT_BLOCK_SIZE</b><var><a name="index-SERPENT_005fBLOCK_005fSIZE-138"></a></var><br>
<blockquote><p>The SERPENT block-size, 16
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>SERPENT_MIN_KEY_SIZE</b><var><a name="index-SERPENT_005fMIN_005fKEY_005fSIZE-139"></a></var><br>
<blockquote><p>Minimum SERPENT key size, 16
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>SERPENT_MAX_KEY_SIZE</b><var><a name="index-SERPENT_005fMAX_005fKEY_005fSIZE-140"></a></var><br>
<blockquote><p>Maximum SERPENT key size, 32
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>SERPENT_KEY_SIZE</b><var><a name="index-SERPENT_005fKEY_005fSIZE-141"></a></var><br>
<blockquote><p>Default SERPENT key size, 32
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>serpent_set_key</b> (<var>struct serpent_ctx *ctx, unsigned length, const uint8_t *key</var>)<var><a name="index-serpent_005fset_005fkey-142"></a></var><br>
<blockquote><p>Initialize the cipher. The same function is used for both encryption and
decryption. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>serpent_encrypt</b> (<var>struct serpent_ctx *ctx, unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-serpent_005fencrypt-143"></a></var><br>
<blockquote><p>Encryption function. <var>length</var> must be an integral multiple of the
block size. If it is more than one block, the data is processed in ECB
mode. <code>src</code> and <code>dst</code> may be equal, but they must not overlap
in any other way. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>serpent_decrypt</b> (<var>struct serpent_ctx *ctx, unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-serpent_005fdecrypt-144"></a></var><br>
<blockquote><p>Analogous to <code>serpent_encrypt</code>
</p></blockquote></div>

<h4 class="subsection">6.2.10 TWOFISH</h4>

<p>Another AES finalist, this one designed by Bruce Schneier and others. 
Nettle defines it in <samp><span class="file">&lt;nettle/twofish.h&gt;</span></samp>.

<div class="defun">
&mdash; Context struct: <b>struct twofish_ctx</b><var><a name="index-struct-twofish_005fctx-145"></a></var><br>
        </div>

<div class="defun">
&mdash; Constant: <b>TWOFISH_BLOCK_SIZE</b><var><a name="index-TWOFISH_005fBLOCK_005fSIZE-146"></a></var><br>
<blockquote><p>The TWOFISH block-size, 16
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>TWOFISH_MIN_KEY_SIZE</b><var><a name="index-TWOFISH_005fMIN_005fKEY_005fSIZE-147"></a></var><br>
<blockquote><p>Minimum TWOFISH key size, 16
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>TWOFISH_MAX_KEY_SIZE</b><var><a name="index-TWOFISH_005fMAX_005fKEY_005fSIZE-148"></a></var><br>
<blockquote><p>Maximum TWOFISH key size, 32
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>TWOFISH_KEY_SIZE</b><var><a name="index-TWOFISH_005fKEY_005fSIZE-149"></a></var><br>
<blockquote><p>Default TWOFISH key size, 32
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>twofish_set_key</b> (<var>struct twofish_ctx *ctx, unsigned length, const uint8_t *key</var>)<var><a name="index-twofish_005fset_005fkey-150"></a></var><br>
<blockquote><p>Initialize the cipher. The same function is used for both encryption and
decryption. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>twofish_encrypt</b> (<var>struct twofish_ctx *ctx, unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-twofish_005fencrypt-151"></a></var><br>
<blockquote><p>Encryption function. <var>length</var> must be an integral multiple of the
block size. If it is more than one block, the data is processed in ECB
mode. <code>src</code> and <code>dst</code> may be equal, but they must not overlap
in any other way. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>twofish_decrypt</b> (<var>struct twofish_ctx *ctx, unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-twofish_005fdecrypt-152"></a></var><br>
<blockquote><p>Analogous to <code>twofish_encrypt</code>
</p></blockquote></div>

<!-- @node nettle_cipher, Cipher Block Chaining, Cipher functions, Reference -->
<!-- @comment  node-name,  next,  previous,  up -->
<h4 class="subsection">6.2.11 <code>struct nettle_cipher</code></h4>

<p>Nettle includes a struct including information about some of the more
regular cipher functions. It should be considered a little experimental,
but can be useful for applications that need a simple way to handle
various algorithms. Nettle defines these structs in
<samp><span class="file">&lt;nettle/nettle-meta.h&gt;</span></samp>.

<div class="defun">
&mdash; Meta struct: <code>struct nettle_cipher</code><var> name context_size block_size key_size set_encrypt_key set_decrypt_key encrypt decrypt<a name="index-g_t_0040code_007bstruct-nettle_005fcipher_007d-153"></a></var><br>
<blockquote><p>The last four attributes are function pointers, of types
<code>nettle_set_key_func</code> and <code>nettle_crypt_func</code>. The first
argument to these functions is a <code>void *</code> pointer to a context
struct, which is of size <code>context_size</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant Struct: struct nettle_cipher <b>nettle_aes128</b><var><a name="index-nettle_005faes128-154"></a></var><br>
&mdash; Constant Struct: struct nettle_cipher <b>nettle_aes192</b><var><a name="index-nettle_005faes192-155"></a></var><br>
&mdash; Constant Struct: struct nettle_cipher <b>nettle_aes256</b><var><a name="index-nettle_005faes256-156"></a></var><br>

   &mdash; Constant Struct: struct nettle_cipher <b>nettle_arctwo40;</b><var><a name="index-nettle_005farctwo40_003b-157"></a></var><br>
&mdash; Constant Struct: struct nettle_cipher <b>nettle_arctwo64;</b><var><a name="index-nettle_005farctwo64_003b-158"></a></var><br>
&mdash; Constant Struct: struct nettle_cipher <b>nettle_arctwo128;</b><var><a name="index-nettle_005farctwo128_003b-159"></a></var><br>
&mdash; Constant Struct: struct nettle_cipher <b>nettle_arctwo_gutmann128;</b><var><a name="index-nettle_005farctwo_005fgutmann128_003b-160"></a></var><br>

   &mdash; Constant Struct: struct nettle_cipher <b>nettle_arcfour128</b><var><a name="index-nettle_005farcfour128-161"></a></var><br>

   &mdash; Constant Struct: struct nettle_cipher <b>nettle_camellia128</b><var><a name="index-nettle_005fcamellia128-162"></a></var><br>
&mdash; Constant Struct: struct nettle_cipher <b>nettle_camellia192</b><var><a name="index-nettle_005fcamellia192-163"></a></var><br>
&mdash; Constant Struct: struct nettle_cipher <b>nettle_camellia256</b><var><a name="index-nettle_005fcamellia256-164"></a></var><br>

   &mdash; Constant Struct: struct nettle_cipher <b>nettle_cast128</b><var><a name="index-nettle_005fcast128-165"></a></var><br>

   &mdash; Constant Struct: struct nettle_cipher <b>nettle_serpent128</b><var><a name="index-nettle_005fserpent128-166"></a></var><br>
&mdash; Constant Struct: struct nettle_cipher <b>nettle_serpent192</b><var><a name="index-nettle_005fserpent192-167"></a></var><br>
&mdash; Constant Struct: struct nettle_cipher <b>nettle_serpent256</b><var><a name="index-nettle_005fserpent256-168"></a></var><br>

   &mdash; Constant Struct: struct nettle_cipher <b>nettle_twofish128</b><var><a name="index-nettle_005ftwofish128-169"></a></var><br>
&mdash; Constant Struct: struct nettle_cipher <b>nettle_twofish192</b><var><a name="index-nettle_005ftwofish192-170"></a></var><br>
&mdash; Constant Struct: struct nettle_cipher <b>nettle_twofish256</b><var><a name="index-nettle_005ftwofish256-171"></a></var><br>
<blockquote>
        <p>Nettle includes such structs for all the <em>regular</em> ciphers, i.e. 
ones without weak keys or other oddities.

        <p>Nettle also exports a list of all these ciphers without weak keys or
other oddities.  This list can be used to dynamically enumerate or
search the supported algorithms:

   &mdash; Constant Struct: struct nettle_cipher ** <b>nettle_ciphers</b><var><a name="index-nettle_005fciphers-172"></a></var><br>

        </div>

<div class="node">
<a name="Cipher-modes"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Keyed-hash-functions">Keyed hash functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Cipher-functions">Cipher functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reference">Reference</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">6.3 Cipher modes</h3>

<p>Cipher modes of operation specifies the procedure to use when encrypting
a message that is larger than the cipher's block size. As explained in
See <a href="#Cipher-functions">Cipher functions</a>, splitting the message into blocks and
processing them independently with the block cipher (Electronic Code
Book mode, <acronym>ECB</acronym>) leaks information. Besides <acronym>ECB</acronym>,
Nettle provides three other modes of operation: Cipher Block Chaining
(<acronym>CBC</acronym>), Counter mode (<acronym>CTR</acronym>), and Galois/Counter mode
(<acronym>gcm</acronym>). <acronym>CBC</acronym> is widely used, but there are a few
subtle issues of information leakage, see, e.g.,
<a href="http://www.kb.cert.org/vuls/id/958563"><acronym>SSH</acronym> <acronym>CBC</acronym> vulnerability</a>. <acronym>CTR</acronym> and <acronym>GCM</acronym>
were standardized more recently, and are believed to be more secure. 
<acronym>GCM</acronym> includes message authentication; for the other modes, one
should always use a <acronym>MAC</acronym> (see <a href="#Keyed-hash-functions">Keyed hash functions</a>) or
signature to authenticate the message.

<ul class="menu">
<li><a accesskey="1" href="#CBC">CBC</a>
<li><a accesskey="2" href="#CTR">CTR</a>
<li><a accesskey="3" href="#GCM">GCM</a>
</ul>

<div class="node">
<a name="CBC"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#CTR">CTR</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Cipher-modes">Cipher modes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Cipher-modes">Cipher modes</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h4 class="subsection">6.3.1 Cipher Block Chaining</h4>

<p><a name="index-Cipher-Block-Chaining-173"></a><a name="index-CBC-Mode-174"></a>
When using <acronym>CBC</acronym> mode, plaintext blocks are not encrypted
independently of each other, like in Electronic Cook Book mode. Instead,
when encrypting a block in <acronym>CBC</acronym> mode, the previous ciphertext
block is XORed with the plaintext before it is fed to the block cipher. 
When encrypting the first block, a random block called an <dfn>IV</dfn>, or
Initialization Vector, is used as the &ldquo;previous ciphertext block&rdquo;. The
IV should be chosen randomly, but it need not be kept secret, and can
even be transmitted in the clear together with the encrypted data.

   <p>In symbols, if <code>E_k</code> is the encryption function of a block cipher,
and <code>IV</code> is the initialization vector, then <code>n</code> plaintext blocks
<code>M_1</code>,<small class="dots">...</small> <code>M_n</code> are transformed into <code>n</code> ciphertext blocks
<code>C_1</code>,<small class="dots">...</small> <code>C_n</code> as follows:

<pre class="example">     C_1 = E_k(IV  XOR M_1)
     C_2 = E_k(C_1 XOR M_2)
     
     ...
     
     C_n = E_k(C_(n-1) XOR M_n)
</pre>
   <p>Nettle's includes two functions for applying a block cipher in Cipher
Block Chaining (<acronym>CBC</acronym>) mode, one for encryption and one for
decryption. These functions uses <code>void *</code> to pass cipher contexts
around.

<div class="defun">
&mdash; Function: void <b>cbc_encrypt</b> (<var>void *ctx, nettle_crypt_func f, unsigned block_size, uint8_t *iv, unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-cbc_005fencrypt-175"></a></var><br>
&mdash; Function: void <b>cbc_decrypt</b> (<var>void *ctx, void </var>(<var>*f</var>)()<var>, unsigned block_size, uint8_t *iv, unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-cbc_005fdecrypt-176"></a></var><br>
<blockquote>
        <p>Applies the encryption or decryption function <var>f</var> in <acronym>CBC</acronym>
mode. The final ciphertext block processed is copied into <var>iv</var>
before returning, so that large message be processed be a sequence of
calls to <code>cbc_encrypt</code>. The function <var>f</var> is of type

        <p><code>void f (void *</code><var>ctx</var><code>, unsigned </code><var>length</var><code>, uint8_t </code><var>dst</var><code>,
const uint8_t *</code><var>src</var><code>)</code>,

     <p class="noindent">and the <code>cbc_encrypt</code> and <code>cbc_decrypt</code> functions pass their
argument <var>ctx</var> on to <var>f</var>. 
</p></blockquote></div>

   <p>There are also some macros to help use these functions correctly.

<div class="defun">
&mdash; Macro: <b>CBC_CTX</b> (<var>context_type, block_size</var>)<var><a name="index-CBC_005fCTX-177"></a></var><br>
<blockquote><p>Expands to
     <pre class="example">          {
             context_type ctx;
             uint8_t iv[block_size];
          }
</pre>
        </blockquote></div>

   <p>It can be used to define a <acronym>CBC</acronym> context struct, either directly,

<pre class="example">     struct CBC_CTX(struct aes_ctx, AES_BLOCK_SIZE) ctx;
</pre>
   <p>or to give it a struct tag,

<pre class="example">     struct aes_cbc_ctx CBC_CTX (struct aes_ctx, AES_BLOCK_SIZE);
</pre>
   <div class="defun">
&mdash; Macro: <b>CBC_SET_IV</b> (<var>ctx, iv</var>)<var><a name="index-CBC_005fSET_005fIV-178"></a></var><br>
<blockquote><p>First argument is a pointer to a context struct as defined by <code>CBC_CTX</code>,
and the second is a pointer to an Initialization Vector (IV) that is
copied into that context. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CBC_ENCRYPT</b> (<var>ctx, f, length, dst, src</var>)<var><a name="index-CBC_005fENCRYPT-179"></a></var><br>
&mdash; Macro: <b>CBC_DECRYPT</b> (<var>ctx, f, length, dst, src</var>)<var><a name="index-CBC_005fDECRYPT-180"></a></var><br>
<blockquote><p>A simpler way to invoke <code>cbc_encrypt</code> and <code>cbc_decrypt</code>. The
first argument is a pointer to a context struct as defined by
<code>CBC_CTX</code>, and the second argument is an encryption or decryption
function following Nettle's conventions. The last three arguments define
the source and destination area for the operation. 
</p></blockquote></div>

   <p>These macros use some tricks to make the compiler display a warning if
the types of <var>f</var> and <var>ctx</var> don't match, e.g. if you try to use
an <code>struct aes_ctx</code> context with the <code>des_encrypt</code> function.

<div class="node">
<a name="CTR"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#GCM">GCM</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#CBC">CBC</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Cipher-modes">Cipher modes</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h4 class="subsection">6.3.2 Counter mode</h4>

<p><a name="index-Counter-Mode-181"></a><a name="index-CTR-Mode-182"></a>
Counter mode (<acronym>CTR</acronym>) uses the block cipher as a keyed
pseudo-random generator. The output of the generator is XORed with the
data to be encrypted. It can be understood as a way to transform a block
cipher to a stream cipher.

   <p>The message is divided into <code>n</code> blocks <code>M_1</code>,<small class="dots">...</small>
<code>M_n</code>, where <code>M_n</code> is of size <code>m</code> which may be smaller
than the block size. Except for the last block, all the message blocks
must be of size equal to the cipher's block size.

   <p>If <code>E_k</code> is the encryption function of a block cipher, <code>IC</code> is
the initial counter, then the <code>n</code> plaintext blocks are
transformed into <code>n</code> ciphertext blocks <code>C_1</code>,<small class="dots">...</small>
<code>C_n</code> as follows:

<pre class="example">     C_1 = E_k(IC) XOR M_1
     C_2 = E_k(IC + 1) XOR M_2
     
     ...
     
     C_(n-1) = E_k(IC + n - 2) XOR M_(n-1)
     C_n = E_k(IC + n - 1) [1..m] XOR M_n
</pre>
   <p>The <acronym>IC</acronym> is the initial value for the counter, it plays a
similar role as the <acronym>IV</acronym> for <acronym>CBC</acronym>. When adding,
<code>IC + x</code>, <acronym>IC</acronym> is interpreted as an integer, in network
byte order. For the last block, <code>E_k(IC + n - 1) [1..m]</code> means that
the cipher output is truncated to <code>m</code> bytes.

<div class="defun">
&mdash; Function: void <b>ctr_crypt</b> (<var>void *ctx, nettle_crypt_func f, unsigned block_size, uint8_t *ctr, unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-ctr_005fcrypt-183"></a></var><br>
<blockquote>
        <p>Applies the encryption function <var>f</var> in <acronym>CTR</acronym> mode. Note that
for <acronym>CTR</acronym> mode, encryption and decryption is the same operation,
and hence <var>f</var> should always be the encryption function for the
underlying block cipher.

        <p>When a message is encrypted using a sequence of calls to
<code>ctr_crypt</code>, all but the last call <em>must</em> use a length that is
a multiple of the block size. 
</p></blockquote></div>

   <p>Like for <acronym>CBC</acronym>, there are also a couple of helper macros.

<div class="defun">
&mdash; Macro: <b>CTR_CTX</b> (<var>context_type, block_size</var>)<var><a name="index-CTR_005fCTX-184"></a></var><br>
<blockquote><p>Expands to
     <pre class="example">          {
             context_type ctx;
             uint8_t ctr[block_size];
          }
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Macro: <b>CTR_SET_COUNTER</b> (<var>ctx, iv</var>)<var><a name="index-CTR_005fSET_005fCOUNTER-185"></a></var><br>
<blockquote><p>First argument is a pointer to a context struct as defined by
<code>CTR_CTX</code>, and the second is a pointer to an initial counter that
is copied into that context. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CTR_CRYPT</b> (<var>ctx, f, length, dst, src</var>)<var><a name="index-CTR_005fCRYPT-186"></a></var><br>
<blockquote><p>A simpler way to invoke <code>ctr_crypt</code>. The first argument is a
pointer to a context struct as defined by <code>CTR_CTX</code>, and the second
argument is an encryption function following Nettle's conventions. The
last three arguments define the source and destination area for the
operation. 
</p></blockquote></div>

<div class="node">
<a name="GCM"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#CTR">CTR</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Cipher-modes">Cipher modes</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h4 class="subsection">6.3.3 Galois counter mode</h4>

<p><a name="index-Galois-Counter-Mode-187"></a><a name="index-GCM-188"></a>
Galois counter mode is the combination of counter mode with message
authentication based on universal hashing. The main objective of the
design is to provide high performance for hardware implementations,
where other popular <acronym>MAC</acronym> algorithms (see <a href="#Keyed-hash-functions">Keyed hash functions</a> becomes a bottleneck for high-speed hardware implementations. 
It was proposed by David A. McGrew and John Viega in 2005, and
recommended by NIST in 2007,
<a href="http://csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf">NIST Special Publication 800-38D</a>. It is constructed on top of a block
cipher which must have a block size of 128 bits.

   <p><acronym>GCM</acronym> is applied to messages of arbitrary length. The inputs
are:

     <ul>
<li>A key, which can be used for many messages. 
<li>An initialization vector (<acronym>IV</acronym>) which <em>must</em> be unique for
each message. 
<li>Additional authenticated data, which is to be included in the message
authentication, but not encrypted. May be empty. 
<li>The plaintext. Maybe empty. 
</ul>

   <p>The outputs are a ciphertext, of the same length as the plaintext, and a
message digest of length 128 bits. Nettle's support for <acronym>GCM</acronym>
consists of a low-level general interface, some convenience macros, and
specific functions for <acronym>GCM</acronym> using <acronym>AES</acronym> as the
underlying cipher. These interfaces are defined in <samp><span class="file">&lt;nettle/gcm.h&gt;</span></samp>

<h5 class="subsubsection">6.3.3.1 General <acronym>GCM</acronym> interface</h5>

<div class="defun">
&mdash; Context struct: <b>struct gcm_key</b><var><a name="index-struct-gcm_005fkey-189"></a></var><br>
<blockquote><p>Message independent hash subkey, and related tables. 
</p></blockquote></div>

<div class="defun">
&mdash; Context struct: <b>struct gcm_ctx</b><var><a name="index-struct-gcm_005fctx-190"></a></var><br>
<blockquote><p>Holds state corresponding to a particular message. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>GCM_BLOCK_SIZE</b><var><a name="index-GCM_005fBLOCK_005fSIZE-191"></a></var><br>
<blockquote><p><acronym>GCM</acronym>'s block size, 16. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>GCM_IV_SIZE</b><var><a name="index-GCM_005fIV_005fSIZE-192"></a></var><br>
<blockquote><p>Recommended size of the <acronym>IV</acronym>, 12. Other sizes are allowed. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>gcm_set_key</b> (<var>struct gcm_key *key, void *cipher, nettle_crypt_func *f</var>)<var><a name="index-gcm_005fset_005fkey-193"></a></var><br>
<blockquote><p>Initializes <var>key</var>. <var>cipher</var> gives a context struct for the
underlying cipher, which must have been previously initialized for
encryption, and <var>f</var> is the encryption function. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>gcm_set_iv</b> (<var>struct gcm_ctx *ctx, const struct gcm_key *key, unsigned length, const uint8_t *iv</var>)<var><a name="index-gcm_005fset_005fiv-194"></a></var><br>
<blockquote><p>Initializes <var>ctx</var> using the given <acronym>IV</acronym>. The <var>key</var>
argument is actually needed only if <var>length</var> differs from
<code>GCM_IV_SIZE</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>gcm_update</b> (<var>struct gcm_ctx *ctx, const struct gcm_key *key, unsigned length, const uint8_t *data</var>)<var><a name="index-gcm_005fupdate-195"></a></var><br>
<blockquote><p>Provides associated data to be authenticated. If used, must be called
before <code>gcm_encrypt</code> or <code>gcm_decrypt</code>. All but the last call
for each message <em>must</em> use a length that is a multiple of the
block size. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>gcm_encrypt</b> (<var>struct gcm_ctx *ctx, const struct gcm_key *key void *cipher, nettle_crypt_func *f, unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-gcm_005fencrypt-196"></a></var><br>
&mdash; Function: void <b>gcm_decrypt</b> (<var>struct gcm_ctx *ctx, const struct gcm_key *key, void *cipher, nettle_crypt_func *f, unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-gcm_005fdecrypt-197"></a></var><br>
<blockquote><p>Encrypts or decrypts the data of a message. <var>cipher</var> is the context
struct for the underlying cipher and <var>f</var> is the encryption function. 
All but the last call for each message <em>must</em> use a length that is
a multiple of the block size. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>gcm_digest</b> (<var>struct gcm_ctx *ctx, const struct gcm_key *key, void *cipher, nettle_crypt_func *f, unsigned length, uint8_t *digest</var>)<var><a name="index-gcm_005fdigest-198"></a></var><br>
<blockquote><p>Extracts the message digest (also known &ldquo;authentication tag&rdquo;). This is
the final operation when processing a message. <var>length</var> is usually
equal to <code>GCM_BLOCK_SIZE</code>, but if you provide a smaller value,
only the first <var>length</var> octets of the digest are written. 
</p></blockquote></div>

   <p>To encrypt a message using <acronym>GCM</acronym>, first initialize a context for
the underlying block cipher with a key to use for encryption. Then call
the above functions in the following order: <code>gcm_set_key</code>,
<code>gcm_set_iv</code>, <code>gcm_update</code>, <code>gcm_encrypt</code>,
<code>gcm_digest</code>. The decryption procedure is analogous, just calling
<code>gcm_decrypt</code> instead of <code>gcm_encrypt</code> (note that
<acronym>GCM</acronym> decryption still uses the encryption function of the
underlying block cipher). To process a new message, using the same key,
call <code>gcm_set_iv</code> with a new <acronym>iv</acronym>.

<h5 class="subsubsection">6.3.3.2 <acronym>GCM</acronym> helper macros</h5>

<p>The following macros are defined.

<div class="defun">
&mdash; Macro: <b>GCM_CTX</b> (<var>context_type</var>)<var><a name="index-GCM_005fCTX-199"></a></var><br>
<blockquote><p>This defines an all-in-one context struct, including the context of the
underlying cipher, the hash subkey, and the per-message state. It expands
to
     <pre class="example">          {
             context_type cipher;
             struct gcm_key key;
             struct gcm_ctx gcm;
          }
</pre>
        </blockquote></div>

   <p>Example use:
<pre class="example">     struct gcm_aes_ctx GCM_CTX(struct aes_ctx);
</pre>
   <p>The following macros operate on context structs of this form.

<div class="defun">
&mdash; Macro: <b>GCM_SET_KEY</b> (<var>ctx, set_key, encrypt, length, data</var>)<var><a name="index-GCM_005fSET_005fKEY-200"></a></var><br>
<blockquote><p>First argument, <var>ctx</var>, is a context struct as defined
by <code>GCM_CTX</code>. <var>set_key</var> and <var>encrypt</var> are functions for
setting the encryption key and for encrypting data using the underlying
cipher. <var>length</var> and <var>data</var> give the key. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GCM_SET_IV</b> (<var>ctx, length, data</var>)<var><a name="index-GCM_005fSET_005fIV-201"></a></var><br>
<blockquote><p>First argument is a context struct as defined by
<code>GCM_CTX</code>. <var>length</var> and <var>data</var> give the initialization
vector (<acronym>IV</acronym>). 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GCM_UPDATE</b> (<var>ctx, length, data</var>)<var><a name="index-GCM_005fUPDATE-202"></a></var><br>
<blockquote><p>Simpler way to call <code>gcm_update</code>. First argument is a context
struct as defined by <code>GCM_CTX</code>
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GCM_ENCRYPT</b> (<var>ctx, encrypt, length, dst, src</var>)<var><a name="index-GCM_005fENCRYPT-203"></a></var><br>
&mdash; Macro: <b>GCM_DECRYPT</b> (<var>ctx, encrypt, length, dst, src</var>)<var><a name="index-GCM_005fDECRYPT-204"></a></var><br>
&mdash; Macro: <b>GCM_DIGEST</b> (<var>ctx, encrypt, length, digest</var>)<var><a name="index-GCM_005fDIGEST-205"></a></var><br>
<blockquote><p>Simpler way to call <code>gcm_encrypt</code>, <code>gcm_decrypt</code> or
<code>gcm_digest</code>. First argument is a context struct as defined by
<code>GCM_CTX</code>. Second argument, <var>encrypt</var>, is a pointer to the
encryption function of the underlying cipher. 
</p></blockquote></div>

<h5 class="subsubsection">6.3.3.3 <acronym>GCM</acronym>-<acronym>AES</acronym> interface</h5>

<p>The following functions implement the common case of <acronym>GCM</acronym> using
<acronym>AES</acronym> as the underlying cipher.

<div class="defun">
&mdash; Context struct: <b>struct gcm_aes_ctx</b><var><a name="index-struct-gcm_005faes_005fctx-206"></a></var><br>
<blockquote><p>The context struct, defined using <code>GCM_CTX</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>gcm_aes_set_key</b> (<var>struct gcm_aes_ctx *ctx, unsigned length, const uint8_t *key</var>)<var><a name="index-gcm_005faes_005fset_005fkey-207"></a></var><br>
<blockquote><p>Initializes <var>ctx</var> using the given key. All valid <acronym>AES</acronym> key
sizes can be used. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>gcm_aes_set_iv</b> (<var>struct gcm_aes_ctx *ctx, unsigned length, const uint8_t *iv</var>)<var><a name="index-gcm_005faes_005fset_005fiv-208"></a></var><br>
<blockquote><p>Initializes the per-message state, using the given <acronym>IV</acronym>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>gcm_aes_update</b> (<var>struct gcm_aes_ctx *ctx, unsigned length, const uint8_t *data</var>)<var><a name="index-gcm_005faes_005fupdate-209"></a></var><br>
<blockquote><p>Provides associated data to be authenticated. If used, must be called
before <code>gcm_aes_encrypt</code> or <code>gcm_aes_decrypt</code>. All but the last call
for each message <em>must</em> use a length that is a multiple of the
block size. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>gcm_aes_encrypt</b> (<var>struct gcm_aes_ctx *ctx, unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-gcm_005faes_005fencrypt-210"></a></var><br>
&mdash; Function: void <b>gcm_aes_decrypt</b> (<var>struct gcm_aes_ctx *ctx, unsigned length, uint8_t *dst, const uint8_t *src</var>)<var><a name="index-gcm_005faes_005fdecrypt-211"></a></var><br>
<blockquote><p>Encrypts or decrypts the data of a message. All but the last call for
each message <em>must</em> use a length that is a multiple of the block
size.

        </blockquote></div>

<div class="defun">
&mdash; Function: void <b>gcm_aes_digest</b> (<var>struct gcm_aes_ctx *ctx, unsigned length, uint8_t *digest</var>)<var><a name="index-gcm_005faes_005fdigest-212"></a></var><br>
<blockquote><p>Extracts the message digest (also known &ldquo;authentication tag&rdquo;). This is
the final operation when processing a message. <var>length</var> is usually
equal to <code>GCM_BLOCK_SIZE</code>, but if you provide a smaller value,
only the first <var>length</var> octets of the digest are written. 
</p></blockquote></div>

<div class="node">
<a name="Keyed-hash-functions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Public_002dkey-algorithms">Public-key algorithms</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Cipher-modes">Cipher modes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reference">Reference</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">6.4 Keyed Hash Functions</h3>

<p><a name="index-Keyed-Hash-Function-213"></a><a name="index-Message-Authentication-Code-214"></a><a name="index-MAC-215"></a>
A <dfn>keyed hash function</dfn>, or <dfn>Message Authentication Code</dfn>
(<acronym>MAC</acronym>) is a function that takes a key and a message, and
produces fixed size <acronym>MAC</acronym>. It should be hard to compute a
message and a matching <acronym>MAC</acronym> without knowledge of the key. It
should also be hard to compute the key given only messages and
corresponding <acronym>MAC</acronym>s.

   <p>Keyed hash functions are useful primarily for message authentication,
when Alice and Bob shares a secret: The sender, Alice, computes the
<acronym>MAC</acronym> and attaches it to the message. The receiver, Bob, also computes
the <acronym>MAC</acronym> of the message, using the same key, and compares that
to Alice's value. If they match, Bob can be assured that
the message has not been modified on its way from Alice.

   <p>However, unlike digital signatures, this assurance is not transferable. 
Bob can't show the message and the <acronym>MAC</acronym> to a third party and
prove that Alice sent that message. Not even if he gives away the key to
the third party. The reason is that the <em>same</em> key is used on both
sides, and anyone knowing the key can create a correct <acronym>MAC</acronym> for
any message. If Bob believes that only he and Alice knows the key, and
he knows that he didn't attach a <acronym>MAC</acronym> to a particular message,
he knows it must be Alice who did it. However, the third party can't
distinguish between a <acronym>MAC</acronym> created by Alice and one created by
Bob.

   <p>Keyed hash functions are typically a lot faster than digital signatures
as well.

<h4 class="subsection">6.4.1 <acronym>HMAC</acronym></h4>

<p>One can build keyed hash functions from ordinary hash functions. Older
constructions simply concatenate secret key and message and hashes that, but
such constructions have weaknesses. A better construction is
<acronym>HMAC</acronym>, described in <cite>RFC 2104</cite>.

   <p>For an underlying hash function <code>H</code>, with digest size <code>l</code> and
internal block size <code>b</code>, <acronym>HMAC-H</acronym> is constructed as
follows: From a given key <code>k</code>, two distinct subkeys <code>k_i</code> and
<code>k_o</code> are constructed, both of length <code>b</code>. The
<acronym>HMAC-H</acronym> of a message <code>m</code> is then computed as <code>H(k_o |
H(k_i | m))</code>, where <code>|</code> denotes string concatenation.

   <p><acronym>HMAC</acronym> keys can be of any length, but it is recommended to use
keys of length <code>l</code>, the digest size of the underlying hash function
<code>H</code>. Keys that are longer than <code>b</code> are shortened to length
<code>l</code> by hashing with <code>H</code>, so arbitrarily long keys aren't
very useful.

   <p>Nettle's <acronym>HMAC</acronym> functions are defined in <samp><span class="file">&lt;nettle/hmac.h&gt;</span></samp>. 
There are abstract functions that use a pointer to a <code>struct
nettle_hash</code> to represent the underlying hash function and <code>void *</code>
pointers that point to three different context structs for that hash
function. There are also concrete functions for <acronym>HMAC-MD5</acronym>,
<acronym>HMAC-RIPEMD160</acronym> <acronym>HMAC-SHA1</acronym>, <acronym>HMAC-SHA256</acronym>, and
<acronym>HMAC-SHA512</acronym>. First, the abstract functions:

<div class="defun">
&mdash; Function: void <b>hmac_set_key</b> (<var>void *outer, void *inner, void *state, const struct nettle_hash *H, unsigned length, const uint8_t *key</var>)<var><a name="index-hmac_005fset_005fkey-216"></a></var><br>
<blockquote><p>Initializes the three context structs from the key. The <var>outer</var> and
<var>inner</var> contexts corresponds to the subkeys <code>k_o</code> and
<code>k_i</code>. <var>state</var> is used for hashing the message, and is
initialized as a copy of the <var>inner</var> context. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>hmac_update</b> (<var>void *state, const struct nettle_hash *H, unsigned length, const uint8_t *data</var>)<var><a name="index-hmac_005fupdate-217"></a></var><br>
<blockquote><p>This function is called zero or more times to process the message. 
Actually, <code>hmac_update(state, H, length, data)</code> is equivalent to
<code>H-&gt;update(state, length, data)</code>, so if you wish you can use the
ordinary update function of the underlying hash function instead. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>hmac_digest</b> (<var>const void *outer, const void *inner, void *state, const struct nettle_hash *H, unsigned length, uint8_t *digest</var>)<var><a name="index-hmac_005fdigest-218"></a></var><br>
<blockquote><p>Extracts the <acronym>MAC</acronym> of the message, writing it to <var>digest</var>. 
<var>outer</var> and <var>inner</var> are not modified. <var>length</var> is usually
equal to <code>H-&gt;digest_size</code>, but if you provide a smaller value,
only the first <var>length</var> octets of the <acronym>MAC</acronym> are written.

        <p>This function also resets the <var>state</var> context so that you can start
over processing a new message (with the same key). 
</p></blockquote></div>

   <p>Like for <acronym>CBC</acronym>, there are some macros to help use these
functions correctly.

<div class="defun">
&mdash; Macro: <b>HMAC_CTX</b> (<var>type</var>)<var><a name="index-HMAC_005fCTX-219"></a></var><br>
<blockquote><p>Expands to
     <pre class="example">          {
             type outer;
             type inner;
             type state;
          }
</pre>
        </blockquote></div>

   <p>It can be used to define a <acronym>HMAC</acronym> context struct, either
directly,

<pre class="example">     struct HMAC_CTX(struct md5_ctx) ctx;
</pre>
   <p>or to give it a struct tag,

<pre class="example">     struct hmac_md5_ctx HMAC_CTX (struct md5_ctx);
</pre>
   <div class="defun">
&mdash; Macro: <b>HMAC_SET_KEY</b> (<var>ctx, H, length, key</var>)<var><a name="index-HMAC_005fSET_005fKEY-220"></a></var><br>
<blockquote><p><var>ctx</var> is a pointer to a context struct as defined by
<code>HMAC_CTX</code>, <var>H</var> is a pointer to a <code>const struct
nettle_hash</code> describing the underlying hash function (so it must match
the type of the components of <var>ctx</var>). The last two arguments specify
the secret key. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>HMAC_DIGEST</b> (<var>ctx, H, length, digest</var>)<var><a name="index-HMAC_005fDIGEST-221"></a></var><br>
<blockquote><p><var>ctx</var> is a pointer to a context struct as defined by
<code>HMAC_CTX</code>, <var>H</var> is a pointer to a <code>const struct
nettle_hash</code> describing the underlying hash function. The last two
arguments specify where the digest is written. 
</p></blockquote></div>

   <p>Note that there is no <code>HMAC_UPDATE</code> macro; simply call
<code>hmac_update</code> function directly, or the update function of the
underlying hash function.

<h4 class="subsection">6.4.2 Concrete <acronym>HMAC</acronym> functions</h4>

<p>Now we come to the specialized <acronym>HMAC</acronym> functions, which are
easier to use than the general <acronym>HMAC</acronym> functions.

<h5 class="subsubsection">6.4.2.1 <acronym>HMAC-MD5</acronym></h5>

<div class="defun">
&mdash; Context struct: <b>struct hmac_md5_ctx</b><var><a name="index-struct-hmac_005fmd5_005fctx-222"></a></var><br>
     </div>

<div class="defun">
&mdash; Function: void <b>hmac_md5_set_key</b> (<var>struct hmac_md5_ctx *ctx, unsigned key_length, const uint8_t *key</var>)<var><a name="index-hmac_005fmd5_005fset_005fkey-223"></a></var><br>
<blockquote><p>Initializes the context with the key. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>hmac_md5_update</b> (<var>struct hmac_md5_ctx *ctx, unsigned length, const uint8_t *data</var>)<var><a name="index-hmac_005fmd5_005fupdate-224"></a></var><br>
<blockquote><p>Process some more data. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>hmac_md5_digest</b> (<var>struct hmac_md5_ctx *ctx, unsigned length, uint8_t *digest</var>)<var><a name="index-hmac_005fmd5_005fdigest-225"></a></var><br>
<blockquote><p>Extracts the <acronym>MAC</acronym>, writing it to <var>digest</var>. <var>length</var> may be smaller than
<code>MD5_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the <acronym>MAC</acronym> are written.

        <p>This function also resets the context for processing new messages, with
the same key. 
</p></blockquote></div>

<h5 class="subsubsection">6.4.2.2 <acronym>HMAC-RIPEMD160</acronym></h5>

<div class="defun">
&mdash; Context struct: <b>struct hmac_ripemd160_ctx</b><var><a name="index-struct-hmac_005fripemd160_005fctx-226"></a></var><br>
     </div>

<div class="defun">
&mdash; Function: void <b>hmac_ripemd160_set_key</b> (<var>struct hmac_ripemd160_ctx *ctx, unsigned key_length, const uint8_t *key</var>)<var><a name="index-hmac_005fripemd160_005fset_005fkey-227"></a></var><br>
<blockquote><p>Initializes the context with the key. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>hmac_ripemd160_update</b> (<var>struct hmac_ripemd160_ctx *ctx, unsigned length, const uint8_t *data</var>)<var><a name="index-hmac_005fripemd160_005fupdate-228"></a></var><br>
<blockquote><p>Process some more data. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>hmac_ripemd160_digest</b> (<var>struct hmac_ripemd160_ctx *ctx, unsigned length, uint8_t *digest</var>)<var><a name="index-hmac_005fripemd160_005fdigest-229"></a></var><br>
<blockquote><p>Extracts the <acronym>MAC</acronym>, writing it to <var>digest</var>. <var>length</var> may be smaller than
<code>RIPEMD160_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the <acronym>MAC</acronym> are written.

        <p>This function also resets the context for processing new messages, with
the same key. 
</p></blockquote></div>

<h5 class="subsubsection">6.4.2.3 <acronym>HMAC-SHA1</acronym></h5>

<div class="defun">
&mdash; Context struct: <b>struct hmac_sha1_ctx</b><var><a name="index-struct-hmac_005fsha1_005fctx-230"></a></var><br>
     </div>

<div class="defun">
&mdash; Function: void <b>hmac_sha1_set_key</b> (<var>struct hmac_sha1_ctx *ctx, unsigned key_length, const uint8_t *key</var>)<var><a name="index-hmac_005fsha1_005fset_005fkey-231"></a></var><br>
<blockquote><p>Initializes the context with the key. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>hmac_sha1_update</b> (<var>struct hmac_sha1_ctx *ctx, unsigned length, const uint8_t *data</var>)<var><a name="index-hmac_005fsha1_005fupdate-232"></a></var><br>
<blockquote><p>Process some more data. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>hmac_sha1_digest</b> (<var>struct hmac_sha1_ctx *ctx, unsigned length, uint8_t *digest</var>)<var><a name="index-hmac_005fsha1_005fdigest-233"></a></var><br>
<blockquote><p>Extracts the <acronym>MAC</acronym>, writing it to <var>digest</var>. <var>length</var> may be smaller than
<code>SHA1_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the <acronym>MAC</acronym> are written.

        <p>This function also resets the context for processing new messages, with
the same key. 
</p></blockquote></div>

<h5 class="subsubsection">6.4.2.4 <acronym>HMAC-SHA256</acronym></h5>

<div class="defun">
&mdash; Context struct: <b>struct hmac_sha256_ctx</b><var><a name="index-struct-hmac_005fsha256_005fctx-234"></a></var><br>
     </div>

<div class="defun">
&mdash; Function: void <b>hmac_sha256_set_key</b> (<var>struct hmac_sha256_ctx *ctx, unsigned key_length, const uint8_t *key</var>)<var><a name="index-hmac_005fsha256_005fset_005fkey-235"></a></var><br>
<blockquote><p>Initializes the context with the key. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>hmac_sha256_update</b> (<var>struct hmac_sha256_ctx *ctx, unsigned length, const uint8_t *data</var>)<var><a name="index-hmac_005fsha256_005fupdate-236"></a></var><br>
<blockquote><p>Process some more data. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>hmac_sha256_digest</b> (<var>struct hmac_sha256_ctx *ctx, unsigned length, uint8_t *digest</var>)<var><a name="index-hmac_005fsha256_005fdigest-237"></a></var><br>
<blockquote><p>Extracts the <acronym>MAC</acronym>, writing it to <var>digest</var>. <var>length</var> may be smaller than
<code>SHA256_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the <acronym>MAC</acronym> are written.

        <p>This function also resets the context for processing new messages, with
the same key. 
</p></blockquote></div>

<h5 class="subsubsection">6.4.2.5 <acronym>HMAC-SHA512</acronym></h5>

<div class="defun">
&mdash; Context struct: <b>struct hmac_sha512_ctx</b><var><a name="index-struct-hmac_005fsha512_005fctx-238"></a></var><br>
     </div>

<div class="defun">
&mdash; Function: void <b>hmac_sha512_set_key</b> (<var>struct hmac_sha512_ctx *ctx, unsigned key_length, const uint8_t *key</var>)<var><a name="index-hmac_005fsha512_005fset_005fkey-239"></a></var><br>
<blockquote><p>Initializes the context with the key. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>hmac_sha512_update</b> (<var>struct hmac_sha512_ctx *ctx, unsigned length, const uint8_t *data</var>)<var><a name="index-hmac_005fsha512_005fupdate-240"></a></var><br>
<blockquote><p>Process some more data. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>hmac_sha512_digest</b> (<var>struct hmac_sha512_ctx *ctx, unsigned length, uint8_t *digest</var>)<var><a name="index-hmac_005fsha512_005fdigest-241"></a></var><br>
<blockquote><p>Extracts the <acronym>MAC</acronym>, writing it to <var>digest</var>. <var>length</var> may be smaller than
<code>SHA512_DIGEST_SIZE</code>, in which case only the first <var>length</var>
octets of the <acronym>MAC</acronym> are written.

        <p>This function also resets the context for processing new messages, with
the same key. 
</p></blockquote></div>

<div class="node">
<a name="Public-key-algorithms"></a>
<a name="Public_002dkey-algorithms"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Randomness">Randomness</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Keyed-hash-functions">Keyed hash functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reference">Reference</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">6.5 Public-key algorithms</h3>

<p>Nettle uses <acronym>GMP</acronym>, the GNU bignum library, for all calculations
with large numbers. In order to use the public-key features of Nettle,
you must install <acronym>GMP</acronym>, at least version 3.0, before compiling
Nettle, and you need to link your programs with <code>-lhogweed -lnettle
-lgmp</code>.

   <p>The concept of <dfn>Public-key</dfn> encryption and digital signatures was
discovered by Whitfield Diffie and Martin E. Hellman and described in a
paper 1976. In traditional, &ldquo;symmetric&rdquo;, cryptography, sender and
receiver share the same keys, and these keys must be distributed in a
secure way. And if there are many users or entities that need to
communicate, each <em>pair</em> needs a shared secret key known by nobody
else.

   <p><a name="index-Public-Key-Cryptography-242"></a><a name="index-One_002dway-function-243"></a>
Public-key cryptography uses trapdoor one-way functions. A
<dfn>one-way function</dfn> is a function <code>F</code> such that it is easy to
compute the value <code>F(x)</code> for any <code>x</code>, but given a value
<code>y</code>, it is hard to compute a corresponding <code>x</code> such that
<code>y = F(x)</code>. Two examples are cryptographic hash functions, and
exponentiation in certain groups.

   <p>A <dfn>trapdoor one-way function</dfn> is a function <code>F</code> that is
one-way, unless one knows some secret information about <code>F</code>. If one
knows the secret, it is easy to compute both <code>F</code> and it's inverse. 
If this sounds strange, look at the <acronym>RSA</acronym> example below.

   <p>Two important uses for one-way functions with trapdoors are public-key
encryption, and digital signatures. The public-key encryption functions
in Nettle are not yet documented; the rest of this chapter is about
digital signatures.

   <p>To use a digital signature algorithm, one must first create a
<dfn>key-pair</dfn>: A public key and a corresponding private key. The private
key is used to sign messages, while the public key is used for verifying
that that signatures and messages match. Some care must be taken when
distributing the public key; it need not be kept secret, but if a bad
guy is able to replace it (in transit, or in some user's list of known
public keys), bad things may happen.

   <p>There are two operations one can do with the keys. The signature
operation takes a message and a private key, and creates a signature for
the message. A signature is some string of bits, usually at most a few
thousand bits or a few hundred octets. Unlike paper-and-ink signatures,
the digital signature depends on the message, so one can't cut it out of
context and glue it to a different message.

   <p>The verification operation takes a public key, a message, and a string
that is claimed to be a signature on the message, and returns true or
false. If it returns true, that means that the three input values
matched, and the verifier can be sure that someone went through with the
signature operation on that very message, and that the &ldquo;someone&rdquo; also
knows the private key corresponding to the public key.

   <p>The desired properties of a digital signature algorithm are as follows:
Given the public key and pairs of messages and valid signatures on them,
it should be hard to compute the private key, and it should also be hard
to create a new message and signature that is accepted by the
verification operation.

   <p>Besides signing meaningful messages, digital signatures can be used for
authorization. A server can be configured with a public key, such that
any client that connects to the service is given a random nonce message. 
If the server gets a reply with a correct signature matching the nonce
message and the configured public key, the client is granted access. So
the configuration of the server can be understood as &ldquo;grant access to
whoever knows the private key corresponding to this particular public
key, and to no others&rdquo;.

<ul class="menu">
<li><a accesskey="1" href="#RSA">RSA</a>:                          The RSA public key algorithm. 
<li><a accesskey="2" href="#DSA">DSA</a>:                          The DSA digital signature algorithm. 
</ul>

<div class="node">
<a name="RSA"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#DSA">DSA</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Public_002dkey-algorithms">Public-key algorithms</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Public_002dkey-algorithms">Public-key algorithms</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h4 class="subsection">6.5.1 <acronym>RSA</acronym></h4>

<p>The <acronym>RSA</acronym> algorithm was the first practical digital signature
algorithm that was constructed. It was described 1978 in a paper by
Ronald Rivest, Adi Shamir and L.M. Adleman, and the technique was also
patented in the <acronym>USA</acronym> in 1983. The patent expired on September 20, 2000, and since
that day, <acronym>RSA</acronym> can be used freely, even in the <acronym>USA</acronym>.

   <p>It's remarkably simple to describe the trapdoor function behind
<acronym>RSA</acronym>. The &ldquo;one-way&rdquo;-function used is

<pre class="example">     F(x) = x^e mod n
</pre>
   <p>I.e. raise x to the <code>e</code>:th power, while discarding all multiples of
<code>n</code>. The pair of numbers <code>n</code> and <code>e</code> is the public key. 
<code>e</code> can be quite small, even <code>e = 3</code> has been used, although
slightly larger numbers are recommended. <code>n</code> should be about 1000
bits or larger.

   <p>If <code>n</code> is large enough, and properly chosen, the inverse of F,
the computation of <code>e</code>:th roots modulo <code>n</code>, is very difficult. 
But, where's the trapdoor?

   <p>Let's first look at how <acronym>RSA</acronym> key-pairs are generated. First
<code>n</code> is chosen as the product of two large prime numbers <code>p</code>
and <code>q</code> of roughly the same size (so if <code>n</code> is 1000 bits,
<code>p</code> and <code>q</code> are about 500 bits each). One also computes the
number <code>phi = (p-1)(q-1)</code>, in mathematical speak, <code>phi</code> is the
order of the multiplicative group of integers modulo n.

   <p>Next, <code>e</code> is chosen. It must have no factors in common with <code>phi</code> (in
particular, it must be odd), but can otherwise be chosen more or less
randomly. <code>e = 65537</code> is a popular choice, because it makes raising
to the <code>e</code>'th power particularly efficient, and being prime, it
usually has no factors common with <code>phi</code>.

   <p>Finally, a number <code>d</code>, <code>d &lt; n</code> is computed such that <code>e d
mod phi = 1</code>. It can be shown that such a number exists (this is why
<code>e</code> and <code>phi</code> must have no common factors), and that for all x,

<pre class="example">     (x^e)^d mod n = x^(ed) mod n = (x^d)^e mod n = x
</pre>
   <p>Using Euclid's algorithm, <code>d</code> can be computed quite easily from
<code>phi</code> and <code>e</code>. But it is still hard to get <code>d</code> without
knowing <code>phi</code>, which depends on the factorization of <code>n</code>.

   <p>So <code>d</code> is the trapdoor, if we know <code>d</code> and <code>y = F(x)</code>, we can
recover x as <code>y^d mod n</code>. <code>d</code> is also the private half of
the <acronym>RSA</acronym> key-pair.

   <p>The most common signature operation for <acronym>RSA</acronym> is defined in
<cite>PKCS#1</cite>, a specification by RSA Laboratories. The message to be
signed is first hashed using a cryptographic hash function, e.g. 
<acronym>MD5</acronym> or <acronym>SHA1</acronym>. Next, some padding, the <acronym>ASN.1</acronym>
&ldquo;Algorithm Identifier&rdquo; for the hash function, and the message digest
itself, are concatenated and converted to a number <code>x</code>. The
signature is computed from <code>x</code> and the private key as <code>s = x^d
mod n</code><a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>. The signature, <code>s</code> is a
number of about the same size of <code>n</code>, and it usually encoded as a
sequence of octets, most significant octet first.

   <p>The verification operation is straight-forward, <code>x</code> is computed
from the message in the same way as above. Then <code>s^e mod n</code> is
computed, the operation returns true if and only if the result equals
<code>x</code>.

<h4 class="subsection">6.5.2 Nettle's <acronym>RSA</acronym> support</h4>

<p>Nettle represents <acronym>RSA</acronym> keys using two structures that contain
large numbers (of type <code>mpz_t</code>).

<div class="defun">
&mdash; Context struct: <b>rsa_public_key</b><var> size n e<a name="index-rsa_005fpublic_005fkey-244"></a></var><br>
<blockquote><p><code>size</code> is the size, in octets, of the modulo, and is used internally. 
<code>n</code> and <code>e</code> is the public key. 
</p></blockquote></div>

<div class="defun">
&mdash; Context struct: <b>rsa_private_key</b><var> size d p q a b c<a name="index-rsa_005fprivate_005fkey-245"></a></var><br>
<blockquote><p><code>size</code> is the size, in octets, of the modulo, and is used internally. 
<code>d</code> is the secret exponent, but it is not actually used when
signing. Instead, the factors <code>p</code> and <code>q</code>, and the parameters
<code>a</code>, <code>b</code> and <code>c</code> are used. They are computed from <code>p</code>,
<code>q</code> and <code>e</code> such that <code>a e mod (p - 1) = 1, b e mod (q -
1) = 1, c q mod p = 1</code>. 
</p></blockquote></div>

   <p>Before use, these structs must be initialized by calling one of

<div class="defun">
&mdash; Function: void <b>rsa_public_key_init</b> (<var>struct rsa_public_key *pub</var>)<var><a name="index-rsa_005fpublic_005fkey_005finit-246"></a></var><br>
&mdash; Function: void <b>rsa_private_key_init</b> (<var>struct rsa_private_key *key</var>)<var><a name="index-rsa_005fprivate_005fkey_005finit-247"></a></var><br>
<blockquote><p>Calls <code>mpz_init</code> on all numbers in the key struct. 
</p></blockquote></div>

   <p>and when finished with them, the space for the numbers must be
deallocated by calling one of

<div class="defun">
&mdash; Function: void <b>rsa_public_key_clear</b> (<var>struct rsa_public_key *pub</var>)<var><a name="index-rsa_005fpublic_005fkey_005fclear-248"></a></var><br>
&mdash; Function: void <b>rsa_private_key_clear</b> (<var>struct rsa_private_key *key</var>)<var><a name="index-rsa_005fprivate_005fkey_005fclear-249"></a></var><br>
<blockquote><p>Calls <code>mpz_clear</code> on all numbers in the key struct. 
</p></blockquote></div>

   <p>In general, Nettle's <acronym>RSA</acronym> functions deviates from Nettle's &ldquo;no
memory allocation&rdquo;-policy. Space for all the numbers, both in the key structs
above, and temporaries, are allocated dynamically. For information on how
to customize allocation, see
See <a href="gmp.html#Custom-Allocation">GMP Allocation</a>.

   <p>When you have assigned values to the attributes of a key, you must call

<div class="defun">
&mdash; Function: int <b>rsa_public_key_prepare</b> (<var>struct rsa_public_key *pub</var>)<var><a name="index-rsa_005fpublic_005fkey_005fprepare-250"></a></var><br>
&mdash; Function: int <b>rsa_private_key_prepare</b> (<var>struct rsa_private_key *key</var>)<var><a name="index-rsa_005fprivate_005fkey_005fprepare-251"></a></var><br>
<blockquote><p>Computes the octet size of the key (stored in the <code>size</code> attribute,
and may also do other basic sanity checks. Returns one if successful, or
zero if the key can't be used, for instance if the modulo is smaller
than the minimum size needed for <acronym>RSA</acronym> operations specified by PKCS#1. 
</p></blockquote></div>

   <p>Before signing or verifying a message, you first hash it with the
appropriate hash function. You pass the hash function's context struct
to the <acronym>RSA</acronym> signature function, and it will extract the message
digest and do the rest of the work. There are also alternative functions
that take the hash digest as argument.

   <p>There is currently no support for using SHA224 or SHA384 with
<acronym>RSA</acronym> signatures, since there's no gain in either computation
time nor message size compared to using SHA256 and SHA512, respectively.

   <p>Creation and verification of signatures is done with the following functions:

<div class="defun">
&mdash; Function: int <b>rsa_md5_sign</b> (<var>const struct rsa_private_key *key, struct md5_ctx *hash, mpz_t signature</var>)<var><a name="index-rsa_005fmd5_005fsign-252"></a></var><br>
&mdash; Function: int <b>rsa_sha1_sign</b> (<var>const struct rsa_private_key *key, struct sha1_ctx *hash, mpz_t signature</var>)<var><a name="index-rsa_005fsha1_005fsign-253"></a></var><br>
&mdash; Function: int <b>rsa_sha256_sign</b> (<var>const struct rsa_private_key *key, struct sha256_ctx *hash, mpz_t signature</var>)<var><a name="index-rsa_005fsha256_005fsign-254"></a></var><br>
&mdash; Function: int <b>rsa_sha512_sign</b> (<var>const struct rsa_private_key *key, struct sha512_ctx *hash, mpz_t signature</var>)<var><a name="index-rsa_005fsha512_005fsign-255"></a></var><br>
<blockquote><p>The signature is stored in <var>signature</var> (which must have been
<code>mpz_init</code>'ed earlier). The hash context is reset so that it can be
used for new messages. Returns one on success, or zero on failure. 
Signing fails if the key is too small for the given hash size, e.g.,
it's not possible to create a signature using SHA512 and a 512-bit
<acronym>RSA</acronym> key. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>rsa_md5_sign_digest</b> (<var>const struct rsa_private_key *key, const uint8_t *digest, mpz_t signature</var>)<var><a name="index-rsa_005fmd5_005fsign_005fdigest-256"></a></var><br>
&mdash; Function: int <b>rsa_sha1_sign_digest</b> (<var>const struct rsa_private_key *key, const uint8_t *digest, mpz_t signature</var>)<var>;<a name="index-rsa_005fsha1_005fsign_005fdigest-257"></a></var><br>
&mdash; Function: int <b>rsa_sha256_sign_digest</b> (<var>const struct rsa_private_key *key, const uint8_t *digest, mpz_t signature</var>)<var>;<a name="index-rsa_005fsha256_005fsign_005fdigest-258"></a></var><br>
&mdash; Function: int <b>rsa_sha512_sign_digest</b> (<var>const struct rsa_private_key *key, const uint8_t *digest, mpz_t signature</var>)<var>;<a name="index-rsa_005fsha512_005fsign_005fdigest-259"></a></var><br>
<blockquote><p>Creates a signature from the given hash digest. <var>digest</var> should
point to a digest of size <code>MD5_DIGEST_SIZE</code>,
<code>SHA1_DIGEST_SIZE</code>, or <code>SHA256_DIGEST_SIZE</code>, respectively. The
signature is stored in <var>signature</var> (which must have been
<code>mpz_init</code>:ed earlier). Returns one on success, or zero on failure. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>rsa_md5_verify</b> (<var>const struct rsa_public_key *key, struct md5_ctx *hash, const mpz_t signature</var>)<var><a name="index-rsa_005fmd5_005fverify-260"></a></var><br>
&mdash; Function: int <b>rsa_sha1_verify</b> (<var>const struct rsa_public_key *key, struct sha1_ctx *hash, const mpz_t signature</var>)<var><a name="index-rsa_005fsha1_005fverify-261"></a></var><br>
&mdash; Function: int <b>rsa_sha256_verify</b> (<var>const struct rsa_public_key *key, struct sha256_ctx *hash, const mpz_t signature</var>)<var><a name="index-rsa_005fsha256_005fverify-262"></a></var><br>
&mdash; Function: int <b>rsa_sha512_verify</b> (<var>const struct rsa_public_key *key, struct sha512_ctx *hash, const mpz_t signature</var>)<var><a name="index-rsa_005fsha512_005fverify-263"></a></var><br>
<blockquote><p>Returns 1 if the signature is valid, or 0 if it isn't. In either case,
the hash context is reset so that it can be used for new messages. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>rsa_md5_verify_digest</b> (<var>const struct rsa_public_key *key, const uint8_t *digest, const mpz_t signature</var>)<var><a name="index-rsa_005fmd5_005fverify_005fdigest-264"></a></var><br>
&mdash; Function: int <b>rsa_sha1_verify_digest</b> (<var>const struct rsa_public_key *key, const uint8_t *digest, const mpz_t signature</var>)<var><a name="index-rsa_005fsha1_005fverify_005fdigest-265"></a></var><br>
&mdash; Function: int <b>rsa_sha256_verify_digest</b> (<var>const struct rsa_public_key *key, const uint8_t *digest, const mpz_t signature</var>)<var><a name="index-rsa_005fsha256_005fverify_005fdigest-266"></a></var><br>
&mdash; Function: int <b>rsa_sha512_verify_digest</b> (<var>const struct rsa_public_key *key, const uint8_t *digest, const mpz_t signature</var>)<var><a name="index-rsa_005fsha512_005fverify_005fdigest-267"></a></var><br>
<blockquote><p>Returns 1 if the signature is valid, or 0 if it isn't. <var>digest</var> should
point to a digest of size <code>MD5_DIGEST_SIZE</code>,
<code>SHA1_DIGEST_SIZE</code>, or <code>SHA256_DIGEST_SIZE</code>, respectively. 
</p></blockquote></div>

   <p>If you need to use the <acronym>RSA</acronym> trapdoor, the private key, in a way
that isn't supported by the above functions Nettle also includes a
function that computes <code>x^d mod n</code> and nothing more, using the
<acronym>CRT</acronym> optimization.

<div class="defun">
&mdash; Function: void <b>rsa_compute_root</b> (<var>struct rsa_private_key *key, mpz_t x, const mpz_t m</var>)<var><a name="index-rsa_005fcompute_005froot-268"></a></var><br>
<blockquote><p>Computes <code>x = m^d</code>, efficiently. 
</p></blockquote></div>

   <p>At last, how do you create new keys?

<div class="defun">
&mdash; Function: int <b>rsa_generate_keypair</b> (<var>struct rsa_public_key *pub, struct rsa_private_key *key, void *random_ctx, nettle_random_func random, void *progress_ctx, nettle_progress_func progress, unsigned n_size, unsigned e_size</var>)<var>;<a name="index-rsa_005fgenerate_005fkeypair-269"></a></var><br>
<blockquote><p>There are lots of parameters. <var>pub</var> and <var>key</var> is where the
resulting key pair is stored. The structs should be initialized, but you
don't need to call <code>rsa_public_key_prepare</code> or
<code>rsa_private_key_prepare</code> after key generation.

        <p><var>random_ctx</var> and <var>random</var> is a randomness generator. 
<code>random(random_ctx, length, dst)</code> should generate <code>length</code>
random octets and store them at <code>dst</code>. For advice, see
See <a href="#Randomness">Randomness</a>.

        <p><var>progress</var> and <var>progress_ctx</var> can be used to get callbacks
during the key generation process, in order to uphold an illusion of
progress. <var>progress</var> can be NULL, in that case there are no
callbacks.

        <p><var>size_n</var> is the desired size of the modulo, in bits. If <var>size_e</var>
is non-zero, it is the desired size of the public exponent and a random
exponent of that size is selected. But if <var>e_size</var> is zero, it is
assumed that the caller has already chosen a value for <code>e</code>, and
stored it in <var>pub</var>. 
Returns one on success, and zero on failure. The function can fail for
example if if <var>n_size</var> is too small, or if <var>e_size</var> is zero and
<code>pub-&gt;e</code> is an even number. 
</p></blockquote></div>

<div class="node">
<a name="DSA"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#RSA">RSA</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Public_002dkey-algorithms">Public-key algorithms</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h4 class="subsection">6.5.3 Nettle's <acronym>DSA</acronym> support</h4>

<p>The <acronym>DSA</acronym> digital signature algorithm is more complex than
<acronym>RSA</acronym>. It was specified during the early 1990s, and in 1994 NIST
published <acronym>FIPS</acronym> 186 which is the authoritative specification. 
Sometimes <acronym>DSA</acronym> is referred to using the acronym <acronym>DSS</acronym>,
for Digital Signature Standard. The most recent revision of the
specification, FIPS186-3, was issueed in 2009, and it adds support for
larger hash functions than <acronym>sha1</acronym>.

   <p>For <acronym>DSA</acronym>, the underlying mathematical problem is the
computation of discreet logarithms. The public key consists of a large
prime <code>p</code>, a small prime <code>q</code> which is a factor of <code>p-1</code>,
a number <code>g</code> which generates a subgroup of order <code>q</code> modulo
<code>p</code>, and an element <code>y</code> in that subgroup.

   <p>In the original <acronym>DSA</acronym>, the size of <code>q</code> is fixed to 160
bits, to match with the <acronym>SHA1</acronym> hash algorithm. The size of
<code>p</code> is in principle unlimited, but the
standard specifies only nine specific sizes: <code>512 + l*64</code>, where
<code>l</code> is between 0 and 8. Thus, the maximum size of <code>p</code> is 1024
bits, and sizes less than 1024 bits are considered obsolete and not
secure.

   <p>The subgroup requirement means that if you compute

<pre class="example">     g^t mod p
</pre>
   <p>for all possible integers <code>t</code>, you will get precisely <code>q</code>
distinct values.

   <p>The private key is a secret exponent <code>x</code>, such that

<pre class="example">     g^x = y mod p
</pre>
   <p>In mathematical speak, <code>x</code> is the <dfn>discrete logarithm</dfn> of
<code>y</code> mod <code>p</code>, with respect to the generator <code>g</code>. The size
of <code>x</code> will also be about the same size as <code>q</code>. The security of the
<acronym>DSA</acronym> algorithm relies on the difficulty of the discrete
logarithm problem. Current algorithms to compute discrete logarithms in
this setting, and hence crack <acronym>DSA</acronym>, are of two types. The first
type works directly in the (multiplicative) group of integers mod
<code>p</code>. The best known algorithm of this type is the Number Field
Sieve, and it's complexity is similar to the complexity of factoring
numbers of the same size as <code>p</code>. The other type works in the
smaller <code>q</code>-sized subgroup generated by <code>g</code>, which has a more
difficult group structure. One good algorithm is Pollard-rho, which has
complexity <code>sqrt(q)</code>.

   <p>The important point is that security depends on the size of <em>both</em>
<code>p</code> and <code>q</code>, and they should be choosen so that the difficulty
of both discrete logarithm methods are comparable. Today, the security
margin of the original <acronym>DSA</acronym> may be uncomfortably small. Using a
<code>p</code> of 1024 bits implies that cracking using the number field sieve
is expected to take about the same time as factoring a 1024-bit
<acronym>RSA</acronym> modulo, and using a <code>q</code> of size 160 bits implies
that cracking using Pollard-rho will take roughly <code>2^80</code> group
operations. With the size of <code>q</code> fixed, tied to the <acronym>SHA1</acronym>
digest size, it may be tempting to increase the size of <code>p</code> to,
say, 4096 bits. This will provide excellent resistance against attacks
like the number field sieve which works in the large group. But it will
do very little to defend against Pollard-rho attacking the small
subgroup; the attacker is slowed down at most by a single factor of 10
due to the more expensive group operation. And the attacker will surely
choose the latter attack.

   <p>The signature generation algorithm is randomized; in order to create a
<acronym>DSA</acronym> signature, you need a good source for random numbers
(see <a href="#Randomness">Randomness</a>). Let us describe the common case of a 160-bit
<code>q</code>.

   <p>To create a signature, one starts with the hash digest of the message,
<code>h</code>, which is a 160 bit number, and a random number <code>k,
0&lt;k&lt;q</code>, also 160 bits. Next, one computes

<pre class="example">     r = (g^k mod p) mod q
     s = k^-1 (h + x r) mod q
</pre>
   <p>The signature is the pair <code>(r, s)</code>, two 160 bit numbers. Note the
two different mod operations when computing <code>r</code>, and the use of the
secret exponent <code>x</code>.

   <p>To verify a signature, one first checks that <code>0 &lt; r,s &lt; q</code>, and
then one computes backwards,

<pre class="example">     w = s^-1 mod q
     v = (g^(w h) y^(w r) mod p) mod q
</pre>
   <p>The signature is valid if <code>v = r</code>. This works out because <code>w =
s^-1 mod q = k (h + x r)^-1 mod q</code>, so that

<pre class="example">     g^(w h) y^(w r) = g^(w h) (g^x)^(w r) = g^(w (h + x r)) = g^k
</pre>
   <p>When reducing mod <code>q</code> this yields <code>r</code>. Note that when
verifying a signature, we don't know either <code>k</code> or <code>x</code>: those
numbers are secret.

   <p>If you can choose between <acronym>RSA</acronym> and <acronym>DSA</acronym>, which one is
best? Both are believed to be secure. <acronym>DSA</acronym> gained popularity in
the late 1990s, as a patent free alternative to <acronym>RSA</acronym>. Now that
the <acronym>RSA</acronym> patents have expired, there's no compelling reason to
want to use <acronym>DSA</acronym>. Today, the original <acronym>DSA</acronym> key size
does not provide a large security margin, and it should probably be
phased out together with <acronym>RSA</acronym> keys of 1024 bits. Using the
revised <acronym>DSA</acronym> algorithm with a larger hash function, in
particular, <acronym>SHA256</acronym>, a 256-bit <code>q</code>, and <code>p</code> of size
2048 bits or more, should provide for a more comfortable security
margin, but these variants are not yet in wide use.

   <p><acronym>DSA</acronym> signatures are smaller than <acronym>RSA</acronym> signatures,
which is important for some specialized applications.

   <p>From a practical point of view, <acronym>DSA</acronym>'s need for a good
randomness source is a serious disadvantage. If you ever use the same
<code>k</code> (and <code>r</code>) for two different message, you leak your private
key.

<h4 class="subsection">6.5.4 Nettle's <acronym>DSA</acronym> support</h4>

<p>Like for <acronym>RSA</acronym>, Nettle represents <acronym>DSA</acronym> keys using two
structures, containing values of type <code>mpz_t</code>. For information on
how to customize allocation, see See <a href="gmp.html#Custom-Allocation">GMP Allocation</a>.

   <p>Most of the <acronym>DSA</acronym> functions are very similar to the
corresponding <acronym>RSA</acronym> functions, but there are a few differences
pointed out below. For a start, there are no functions corresponding to
<code>rsa_public_key_prepare</code> and <code>rsa_private_key_prepare</code>.

<div class="defun">
&mdash; Context struct: <b>dsa_public_key</b><var> p q g y<a name="index-dsa_005fpublic_005fkey-270"></a></var><br>
<blockquote><p>The public parameters described above. 
</p></blockquote></div>

<div class="defun">
&mdash; Context struct: <b>dsa_private_key</b><var> x<a name="index-dsa_005fprivate_005fkey-271"></a></var><br>
<blockquote><p>The private key <code>x</code>. 
</p></blockquote></div>

   <p>Before use, these structs must be initialized by calling one of

<div class="defun">
&mdash; Function: void <b>dsa_public_key_init</b> (<var>struct dsa_public_key *pub</var>)<var><a name="index-dsa_005fpublic_005fkey_005finit-272"></a></var><br>
&mdash; Function: void <b>dsa_private_key_init</b> (<var>struct dsa_private_key *key</var>)<var><a name="index-dsa_005fprivate_005fkey_005finit-273"></a></var><br>
<blockquote><p>Calls <code>mpz_init</code> on all numbers in the key struct. 
</p></blockquote></div>

   <p>When finished with them, the space for the numbers must be
deallocated by calling one of

<div class="defun">
&mdash; Function: void <b>dsa_public_key_clear</b> (<var>struct dsa_public_key *pub</var>)<var><a name="index-dsa_005fpublic_005fkey_005fclear-274"></a></var><br>
&mdash; Function: void <b>dsa_private_key_clear</b> (<var>struct dsa_private_key *key</var>)<var><a name="index-dsa_005fprivate_005fkey_005fclear-275"></a></var><br>
<blockquote><p>Calls <code>mpz_clear</code> on all numbers in the key struct. 
</p></blockquote></div>

   <p>Signatures are represented using the structure below, and need to be
initialized and cleared in the same way as the key structs.

<div class="defun">
&mdash; Context struct: <b>dsa_signature</b><var> r s<a name="index-dsa_005fsignature-276"></a></var><br>
        </div>

<div class="defun">
&mdash; Function: void <b>dsa_signature_init</b> (<var>struct dsa_signature *signature</var>)<var><a name="index-dsa_005fsignature_005finit-277"></a></var><br>
&mdash; Function: void <b>dsa_signature_clear</b> (<var>struct dsa_signature *signature</var>)<var><a name="index-dsa_005fsignature_005fclear-278"></a></var><br>
<blockquote><p>You must call <code>dsa_signature_init</code> before creating or using a
signature, and call <code>dsa_signature_clear</code> when you are finished
with it. 
</p></blockquote></div>

   <p>For signing, you need to provide both the public and the private key
(unlike <acronym>RSA</acronym>, where the private key struct includes all
information needed for signing), and a source for random numbers. 
Signatures can use the <acronym>SHA1</acronym> or the <acronym>SHA256</acronym> hash
function, although the implementation of <acronym>DSA</acronym> with
<acronym>SHA256</acronym> should be considered somewhat experimental due to lack
of official test vectors and interoperability testing.

<div class="defun">
&mdash; Function: int <b>dsa_sha1_sign</b> (<var>const struct dsa_public_key *pub, const struct dsa_private_key *key, void *random_ctx, nettle_random_func random, struct sha1_ctx *hash, struct dsa_signature *signature</var>)<var><a name="index-dsa_005fsha1_005fsign-279"></a></var><br>
&mdash; Function: int <b>dsa_sha1_sign_digest</b> (<var>const struct dsa_public_key *pub, const struct dsa_private_key *key, void *random_ctx, nettle_random_func random, const uint8_t *digest, struct dsa_signature *signature</var>)<var><a name="index-dsa_005fsha1_005fsign_005fdigest-280"></a></var><br>
&mdash; Function: int <b>dsa_sha256_sign</b> (<var>const struct dsa_public_key *pub, const struct dsa_private_key *key, void *random_ctx, nettle_random_func random, struct sha256_ctx *hash, struct dsa_signature *signature</var>)<var><a name="index-dsa_005fsha256_005fsign-281"></a></var><br>
&mdash; Function: int <b>dsa_sha256_sign_digest</b> (<var>const struct dsa_public_key *pub, const struct dsa_private_key *key, void *random_ctx, nettle_random_func random, const uint8_t *digest, struct dsa_signature *signature</var>)<var><a name="index-dsa_005fsha256_005fsign_005fdigest-282"></a></var><br>
<blockquote><p>Creates a signature from the given hash context or digest. 
<var>random_ctx</var> and <var>random</var> is a randomness generator. 
<code>random(random_ctx, length, dst)</code> should generate <code>length</code>
random octets and store them at <code>dst</code>. For advice, see
See <a href="#Randomness">Randomness</a>. Returns one on success, or zero on failure. 
Signing fails if the key size and the hash size don't match. 
</p></blockquote></div>

   <p>Verifying signatures is a little easier, since no randomness generator is
needed. The functions are

<div class="defun">
&mdash; Function: int <b>dsa_sha1_verify</b> (<var>const struct dsa_public_key *key, struct sha1_ctx *hash, const struct dsa_signature *signature</var>)<var><a name="index-dsa_005fsha1_005fverify-283"></a></var><br>
&mdash; Function: int <b>dsa_sha1_verify_digest</b> (<var>const struct dsa_public_key *key, const uint8_t *digest, const struct dsa_signature *signature</var>)<var><a name="index-dsa_005fsha1_005fverify_005fdigest-284"></a></var><br>
&mdash; Function: int <b>dsa_sha256_verify</b> (<var>const struct dsa_public_key *key, struct sha256_ctx *hash, const struct dsa_signature *signature</var>)<var><a name="index-dsa_005fsha256_005fverify-285"></a></var><br>
&mdash; Function: int <b>dsa_sha256_verify_digest</b> (<var>const struct dsa_public_key *key, const uint8_t *digest, const struct dsa_signature *signature</var>)<var><a name="index-dsa_005fsha256_005fverify_005fdigest-286"></a></var><br>
<blockquote><p>Verifies a signature. Returns 1 if the signature is valid, otherwise 0. 
</p></blockquote></div>

   <p>Key generation uses mostly the same parameters as the corresponding
<acronym>RSA</acronym> function.

<div class="defun">
&mdash; Function: int <b>dsa_generate_keypair</b> (<var>struct dsa_public_key *pub, struct dsa_private_key *key, void *random_ctx, nettle_random_func random, void *progress_ctx, nettle_progress_func progress, unsigned p_bits, unsigned q_bits</var>)<var><a name="index-dsa_005fgenerate_005fkeypair-287"></a></var><br>
<blockquote><p><var>pub</var> and <var>key</var> is where the resulting key pair is stored. The
structs should be initialized before you call this function.

        <p><var>random_ctx</var> and <var>random</var> is a randomness generator. 
<code>random(random_ctx, length, dst)</code> should generate <code>length</code>
random octets and store them at <code>dst</code>. For advice, see
See <a href="#Randomness">Randomness</a>.

        <p><var>progress</var> and <var>progress_ctx</var> can be used to get callbacks
during the key generation process, in order to uphold an illusion of
progress. <var>progress</var> can be NULL, in that case there are no
callbacks.

        <p><var>p_bits</var> and <var>q_bits</var> are the desired sizes of <code>p</code> and
<code>q</code>. To generate keys that conform to the original <acronym>DSA</acronym>
standard, you must use <code>q_bits = 160</code> and select <var>p_bits</var> of
the form <code>p_bits = 512 + l*64</code>, for <code>0 &lt;= l &lt;= 8</code>, where the
smaller sizes are no longer recommended, so you should most likely stick
to <code>p_bits = 1024</code>. Non-standard sizes are possible, in particular
<code>p_bits</code> larger than 1024, although <acronym>DSA</acronym> implementations
can not in general be expected to support such keys. Also note that
using very large <var>p_bits</var>, with <var>q_bits</var> fixed at 160, doesn't
make much sense, because the security is also limited by the size of the
smaller prime. Using a larger <code>q_bits</code> requires switchign to a
larger hash function. To generate <acronym>DSA</acronym> keys for use with
<acronym>SHA256</acronym>, use <code>q_bits = 256</code> and, e.g., <code>p_bits =
2048</code>.

        <p>Returns one on success, and zero on failure. The function will fail if
<var>q_bits</var> is neither 160 nor 256, or if <var>p_bits</var> is unreasonably
small. 
</p></blockquote></div>

<div class="node">
<a name="Randomness"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Miscellaneous-functions">Miscellaneous functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Public_002dkey-algorithms">Public-key algorithms</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reference">Reference</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">6.6 Randomness</h3>

<p><a name="index-Randomness-288"></a>
A crucial ingredient in many cryptographic contexts is randomness: Let
<code>p</code> be a random prime, choose a random initialization vector
<code>iv</code>, a random key <code>k</code> and a random exponent <code>e</code>, etc. In
the theories, it is assumed that you have plenty of randomness around. 
If this assumption is not true in practice, systems that are otherwise
perfectly secure, can be broken. Randomness has often turned out to be
the weakest link in the chain.

   <p>In non-cryptographic applications, such as games as well as scientific
simulation, a good randomness generator usually means a generator that
has good statistical properties, and is seeded by some simple function
of things like the current time, process id, and host name.

   <p>However, such a generator is inadequate for cryptography, for at least
two reasons:

     <ul>
<li>It's too easy for an attacker to guess the initial seed. Even if it will
take some 2^32 tries before he guesses right, that's far too easy. For
example, if the process id is 16 bits, the resolution of &ldquo;current time&rdquo;
is one second, and the attacker knows what day the generator was seeded,
there are only about 2^32 possibilities to try if all possible values
for the process id and time-of-day are tried.

     <li>The generator output reveals too much. By observing only a small segment
of the generator's output, its internal state can be recovered, and from
there, all previous output and all future output can be computed by the
attacker. 
</ul>

   <p>A randomness generator that is used for cryptographic purposes must have
better properties. Let's first look at the seeding, as the issues here
are mostly independent of the rest of the generator. The initial state
of the generator (its seed) must be unguessable by the attacker. So
what's unguessable? It depends on what the attacker already knows. The
concept used in information theory to reason about such things is called
&ldquo;entropy&rdquo;, or &ldquo;conditional entropy&rdquo; (not to be confused with the
thermodynamic concept with the same name). A reasonable requirement is
that the seed contains a conditional entropy of at least some 80-100
bits. This property can be explained as follows: Allow the attacker to
ask <code>n</code> yes-no-questions, of his own choice, about the seed. If
the attacker, using this question-and-answer session, as well as any
other information he knows about the seeding process, still can't guess
the seed correctly, then the conditional entropy is more than <code>n</code>
bits.

   <p><a name="index-Entropy-289"></a><a name="index-Conditional-entropy-290"></a>
Let's look at an example. Say information about timing of received
network packets is used in the seeding process. If there is some random
network traffic going on, this will contribute some bits of entropy or
&ldquo;unguessability&rdquo; to the seed. However, if the attacker can listen in to
the local network, or if all but a small number of the packets were
transmitted by machines that the attacker can monitor, this additional
information makes the seed easier for the attacker to figure out. Even
if the information is exactly the same, the conditional entropy, or
unguessability, is smaller for an attacker that knows some of it already
before the hypothetical question-and-answer session.

   <p>Seeding of good generators is usually based on several sources. The key
point here is that the amount of unguessability that each source
contributes, depends on who the attacker is. Some sources that have been
used are:

     <dl>
<dt>High resolution timing of i/o activities<dd>Such as completed blocks from spinning hard disks, network packets, etc. 
Getting access to such information is quite system dependent, and not
all systems include suitable hardware. If available, it's one of the
better randomness source one can find in a digital, mostly predictable,
computer.

     <br><dt>User activity<dd>Timing and contents of user interaction events is another popular source
that is available for interactive programs (even if I suspect that it is
sometimes used in order to make the user feel good, not because the
quality of the input is needed or used properly). Obviously, not
available when a machine is unattended. Also beware of networks: User
interaction that happens across a long serial cable, <acronym>TELNET</acronym>
session, or even <acronym>SSH</acronym> session may be visible to an attacker, in
full or partially.

     <br><dt>Audio input<dd>Any room, or even a microphone input that's left unconnected, is a
source of some random background noise, which can be fed into the
seeding process.

     <br><dt>Specialized hardware<dd>Hardware devices with the sole purpose of generating random data have
been designed. They range from radioactive samples with an attached
Geiger counter, to amplification of the inherent noise in electronic
components such as diodes and resistors, to low-frequency sampling of
chaotic systems. Hashing successive images of a Lava lamp is a
spectacular example of the latter type.

     <br><dt>Secret information<dd>Secret information, such as user passwords or keys, or private files
stored on disk, can provide some unguessability. A problem is that if
the information is revealed at a later time, the unguessability
vanishes. Another problem is that this kind of information tends to be
fairly constant, so if you rely on it and seed your generator regularly,
you risk constructing almost similar seeds or even constructing the same
seed more than once. 
</dl>

   <p>For all practical sources, it's difficult but important to provide a
reliable lower bound on the amount of unguessability that it provides. 
Two important points are to make sure that the attacker can't observe
your sources (so if you like the Lava lamp idea, remember that you have
to get your own lamp, and not put it by a window or anywhere else where
strangers can see it), and that hardware failures are detected. What if
the bulb in the Lava lamp, which you keep locked into a cupboard
following the above advice, breaks after a few months?

   <p>So let's assume that we have been able to find an unguessable seed,
which contains at least 80 bits of conditional entropy, relative to all
attackers that we care about (typically, we must at the very least
assume that no attacker has root privileges on our machine).

   <p>How do we generate output from this seed, and how much can we get? Some
generators (notably the Linux <samp><span class="file">/dev/random</span></samp> generator) tries to
estimate available entropy and restrict the amount of output. The goal
is that if you read 128 bits from <samp><span class="file">/dev/random</span></samp>, you should get 128
&ldquo;truly random&rdquo; bits. This is a property that is useful in some
specialized circumstances, for instance when generating key material for
a one time pad, or when working with unconditional blinding, but in most
cases, it doesn't matter much. For most application, there's no limit on
the amount of useful &ldquo;random&rdquo; data that we can generate from a small
seed; what matters is that the seed is unguessable and that the
generator has good cryptographic properties.

   <p>At the heart of all generators lies its internal state. Future output
is determined by the internal state alone. Let's call it the generator's
key. The key is initialized from the unguessable seed. Important
properties of a generator are:

     <dl>
<dt><dfn>Key-hiding</dfn><dd>An attacker observing the output should not be able to recover the
generator's key.

     <br><dt><dfn>Independence of outputs</dfn><dd>Observing some of the output should not help the attacker to guess
previous or future output.

     <br><dt><dfn>Forward secrecy</dfn><dd>Even if an attacker compromises the generator's key, he should not be
able to guess the generator output <em>before</em> the key compromise.

     <br><dt><dfn>Recovery from key compromise</dfn><dd>If an attacker compromises the generator's key, he can compute
<em>all</em> future output. This is inevitable if the generator is seeded
only once, at startup. However, the generator can provide a reseeding
mechanism, to achieve recovery from key compromise. More precisely: If
the attacker compromises the key at a particular time <code>t_1</code>, there
is another later time <code>t_2</code>, such that if the attacker observes all
output generated between <code>t_1</code> and <code>t_2</code>, he still can't guess
what output is generated after <code>t_2</code>.

   </dl>

   <p>Nettle includes one randomness generator that is believed to have all
the above properties, and two simpler ones.

   <p><acronym>ARCFOUR</acronym>, like any stream cipher, can be used as a randomness
generator. Its output should be of reasonable quality, if the seed is
hashed properly before it is used with <code>arcfour_set_key</code>. There's
no single natural way to reseed it, but if you need reseeding, you
should be using Yarrow instead.

   <p>The &ldquo;lagged Fibonacci&rdquo; generator in <samp><span class="file">&lt;nettle/knuth-lfib.h&gt;</span></samp> is a
fast generator with good statistical properties, but is <strong>not</strong> for
cryptographic use, and therefore not documented here. It is included
mostly because the Nettle test suite needs to generate some test data
from a small seed.

   <p>The recommended generator to use is Yarrow, described below.

<h4 class="subsection">6.6.1 Yarrow</h4>

<p>Yarrow is a family of pseudo-randomness generators, designed for
cryptographic use, by John Kelsey, Bruce Schneier and Niels Ferguson. 
Yarrow-160 is described in a paper at
<a href="http://www.counterpane.com/yarrow.html">http://www.counterpane.com/yarrow.html</a>, and it uses <acronym>SHA1</acronym>
and triple-DES, and has a 160-bit internal state. Nettle implements
Yarrow-256, which is similar, but uses <acronym>SHA256</acronym> and
<acronym>AES</acronym> to get an internal state of 256 bits.

   <p>Yarrow was an almost finished project, the paper mentioned above is the
closest thing to a specification for it, but some smaller details are
left out. There is no official reference implementation or test cases. 
This section includes an overview of Yarrow, but for the details of
Yarrow-256, as implemented by Nettle, you have to consult the source
code. Maybe a complete specification can be written later.

   <p>Yarrow can use many sources (at least two are needed for proper
reseeding), and two randomness &ldquo;pools&rdquo;, referred to as the &ldquo;slow pool&rdquo; and
the &ldquo;fast pool&rdquo;. Input from the sources is fed alternatingly into the
two pools. When one of the sources has contributed 100 bits of entropy
to the fast pool, a &ldquo;fast reseed&rdquo; happens and the fast pool is mixed
into the internal state. When at least two of the sources have
contributed at least 160 bits each to the slow pool, a &ldquo;slow reseed&rdquo;
takes place. The contents of both pools are mixed into the internal
state. These procedures should ensure that the generator will eventually
recover after a key compromise.

   <p>The output is generated by using <acronym>AES</acronym> to encrypt a counter,
using the generator's current key. After each request for output,
another 256 bits are generated which replace the key. This ensures
forward secrecy.

   <p>Yarrow can also use a <dfn>seed file</dfn> to save state across restarts. 
Yarrow is seeded by either feeding it the contents of the previous seed
file, or feeding it input from its sources until a slow reseed happens.

   <p>Nettle defines Yarrow-256 in <samp><span class="file">&lt;nettle/yarrow.h&gt;</span></samp>.

<div class="defun">
&mdash; Context struct: <b>struct yarrow256_ctx</b><var><a name="index-struct-yarrow256_005fctx-291"></a></var><br>
        </div>

<div class="defun">
&mdash; Context struct: <b>struct yarrow_source</b><var><a name="index-struct-yarrow_005fsource-292"></a></var><br>
<blockquote><p>Information about a single source. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>YARROW256_SEED_FILE_SIZE</b><var><a name="index-YARROW256_005fSEED_005fFILE_005fSIZE-293"></a></var><br>
<blockquote><p>Recommanded size of the Yarrow-256 seed file. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>yarrow256_init</b> (<var>struct yarrow256_ctx *ctx, unsigned nsources, struct yarrow_source *sources</var>)<var><a name="index-yarrow256_005finit-294"></a></var><br>
<blockquote><p>Initializes the yarrow context, and its <var>nsources</var> sources. It's
possible to call it with <var>nsources</var>=0 and <var>sources</var>=NULL, if
you don't need the update features. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>yarrow256_seed</b> (<var>struct yarrow256_ctx *ctx, unsigned length, uint8_t *seed_file</var>)<var><a name="index-yarrow256_005fseed-295"></a></var><br>
<blockquote><p>Seeds Yarrow-256 from a previous seed file. <var>length</var> should be at least
<code>YARROW256_SEED_FILE_SIZE</code>, but it can be larger.

        <p>The generator will trust you that the <var>seed_file</var> data really is
unguessable. After calling this function, you <em>must</em> overwrite the old
seed file with newly generated data from <code>yarrow256_random</code>. If it's
possible for several processes to read the seed file at about the same
time, access must be coordinated using some locking mechanism. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>yarrow256_update</b> (<var>struct yarrow256_ctx *ctx, unsigned source, unsigned entropy, unsigned length, const uint8_t *data</var>)<var><a name="index-yarrow256_005fupdate-296"></a></var><br>
<blockquote><p>Updates the generator with data from source <var>SOURCE</var> (an index that
must be smaller than the number of sources). <var>entropy</var> is your
estimated lower bound for the entropy in the data, measured in bits. 
Calling update with zero <var>entropy</var> is always safe, no matter if the
data is random or not.

        <p>Returns 1 if a reseed happened, in which case an application using a
seed file may want to generate new seed data with
<code>yarrow256_random</code> and overwrite the seed file. Otherwise, the
function returns 0. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>yarrow256_random</b> (<var>struct yarrow256_ctx *ctx, unsigned length, uint8_t *dst</var>)<var><a name="index-yarrow256_005frandom-297"></a></var><br>
<blockquote><p>Generates <var>length</var> octets of output. The generator must be seeded
before you call this function.

        <p>If you don't need forward secrecy, e.g. if you need non-secret
randomness for initialization vectors or padding, you can gain some
efficiency by buffering, calling this function for reasonably large
blocks of data, say 100-1000 octets at a time. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>yarrow256_is_seeded</b> (<var>struct yarrow256_ctx *ctx</var>)<var><a name="index-yarrow256_005fis_005fseeded-298"></a></var><br>
<blockquote><p>Returns 1 if the generator is seeded and ready to generate output,
otherwise 0. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: unsigned <b>yarrow256_needed_sources</b> (<var>struct yarrow256_ctx *ctx</var>)<var><a name="index-yarrow256_005fneeded_005fsources-299"></a></var><br>
<blockquote><p>Returns the number of sources that must reach the threshold before a
slow reseed will happen. Useful primarily when the generator is unseeded. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>yarrow256_fast_reseed</b> (<var>struct yarrow256_ctx *ctx</var>)<var><a name="index-yarrow256_005ffast_005freseed-300"></a></var><br>
&mdash; Function: void <b>yarrow256_slow_reseed</b> (<var>struct yarrow256_ctx *ctx</var>)<var><a name="index-yarrow256_005fslow_005freseed-301"></a></var><br>
<blockquote><p>Causes a fast or slow reseed to take place immediately, regardless of the
current entropy estimates of the two pools. Use with care. 
</p></blockquote></div>

   <p>Nettle includes an entropy estimator for one kind of input source: User
keyboard input.

<div class="defun">
&mdash; Context struct: <b>struct yarrow_key_event_ctx</b><var><a name="index-struct-yarrow_005fkey_005fevent_005fctx-302"></a></var><br>
<blockquote><p>Information about recent key events. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>yarrow_key_event_init</b> (<var>struct yarrow_key_event_ctx *ctx</var>)<var><a name="index-yarrow_005fkey_005fevent_005finit-303"></a></var><br>
<blockquote><p>Initializes the context. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: unsigned <b>yarrow_key_event_estimate</b> (<var>struct yarrow_key_event_ctx *ctx, unsigned key, unsigned time</var>)<var><a name="index-yarrow_005fkey_005fevent_005festimate-304"></a></var><br>
<blockquote><p><var>key</var> is the id of the key (ASCII value, hardware key code, X
keysym, <small class="dots">...</small>, it doesn't matter), and <var>time</var> is the timestamp of
the event. The time must be given in units matching the resolution by
which you read the clock. If you read the clock with microsecond
precision, <var>time</var> should be provided in units of microseconds. But
if you use <code>gettimeofday</code> on a typical Unix system where the clock
ticks 10 or so microseconds at a time, <var>time</var> should be given in
units of 10 microseconds.

        <p>Returns an entropy estimate, in bits, suitable for calling
<code>yarrow256_update</code>. Usually, 0, 1 or 2 bits. 
</p></blockquote></div>

<div class="node">
<a name="Miscellaneous-functions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Compatibility-functions">Compatibility functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Randomness">Randomness</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reference">Reference</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">6.7 Miscellaneous functions</h3>

<div class="defun">
&mdash; Function: uint8_t * <b>memxor</b> (<var>uint8_t *dst, const uint8_t *src, size_t n</var>)<var><a name="index-memxor-305"></a></var><br>
<blockquote><p>XORs the source area on top of the destination area. The interface
doesn't follow the Nettle conventions, because it is intended to be
similar to the ANSI-C <code>memcpy</code> function. 
</p></blockquote></div>

   <p><code>memxor</code> is declared in <samp><span class="file">&lt;nettle/memxor.h&gt;</span></samp>.

<div class="node">
<a name="Compatibility-functions"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Miscellaneous-functions">Miscellaneous functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reference">Reference</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h3 class="section">6.8 Compatibility functions</h3>

<p>For convenience, Nettle includes alternative interfaces to some
algorithms, for compatibility with some other popular crypto toolkits. 
These are not fully documented here; refer to the source or to the
documentation for the original implementation.

   <p>MD5 is defined in [RFC 1321], which includes a reference implementation. 
Nettle defines a compatible interface to MD5 in
<samp><span class="file">&lt;nettle/md5-compat.h&gt;</span></samp>. This file defines the typedef
<code>MD5_CTX</code>, and declares the functions <code>MD5Init</code>, <code>MD5Update</code> and
<code>MD5Final</code>.

   <p>Eric Young's &ldquo;libdes&rdquo; (also part of OpenSSL) is a quite popular DES
implementation. Nettle includes a subset if its interface in
<samp><span class="file">&lt;nettle/des-compat.h&gt;</span></samp>. This file defines the typedefs
<code>des_key_schedule</code> and <code>des_cblock</code>, two constants
<code>DES_ENCRYPT</code> and <code>DES_DECRYPT</code>, and declares one global
variable <code>des_check_key</code>, and the functions <code>des_cbc_cksum</code>
<code>des_cbc_encrypt</code>, <code>des_ecb2_encrypt</code>,
<code>des_ecb3_encrypt</code>, <code>des_ecb_encrypt</code>,
<code>des_ede2_cbc_encrypt</code>, <code>des_ede3_cbc_encrypt</code>,
<code>des_is_weak_key</code>, <code>des_key_sched</code>, <code>des_ncbc_encrypt</code>
<code>des_set_key</code>, and <code>des_set_odd_parity</code>.

<div class="node">
<a name="Nettle-soup"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Installation">Installation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Reference">Reference</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">7 Traditional Nettle Soup</h2>

<p>For the serious nettle hacker, here is a recipe for nettle soup. 4 servings.

     <ul>
<li>1 liter fresh nettles (urtica dioica)
<li>2 tablespoons butter
<li>3 tablespoons flour
<li>1 liter stock (meat or vegetable)
<li>1/2 teaspoon salt
<li>a tad white pepper
<li>some cream or milk
</ul>

   <p>Gather 1 liter fresh nettles. Use gloves! Small, tender shoots are
preferable but the tops of larger nettles can also be used.

   <p>Rinse the nettles very well. Boil them for 10 minutes in lightly salted
water. Strain the nettles and save the water. Hack the nettles. Melt the
butter and mix in the flour. Dilute with stock and the nettle-water you
saved earlier. Add the hacked nettles. If you wish you can add some milk
or cream at this stage. Bring to a boil and let boil for a few minutes. 
Season with salt and pepper.

   <p>Serve with boiled egg-halves.

<!-- And the original Swedish version. -->
<div class="node">
<a name="Installation"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Index">Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Nettle-soup">Nettle soup</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">8 Installation</h2>

<p>Nettle uses <samp><span class="command">autoconf</span></samp>. To build it, unpack the source and run

<pre class="example">     ./configure
     make
     make check
     make install
</pre>
   <p class="noindent">to install in the default location, <samp><span class="file">/usr/local</span></samp>. The library files
are installed in <samp><span class="file">/use/local/lib/libnettle.a</span></samp>
<samp><span class="file">/use/local/lib/libhogweed.a</span></samp> and the include files are installed
in <samp><span class="file">/use/local/include/nettle/</span></samp>.

   <p>To get a list of configure options, use <code>./configure --help</code>.

   <p>By default, only static libraries are built and installed. To also build
and install shared libraries, use the <samp><span class="option"> --enable-shared</span></samp> option
to <samp><span class="command">./configure</span></samp>.

   <p>Using GNU make is recommended. For other make programs, in particular
BSD make, you may have to use the <samp><span class="option">--disable-dependency-tracking</span></samp>
option to <samp><span class="command">./configure</span></samp>.

<div class="node">
<a name="Index"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Installation">Installation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="unnumbered">Function and Concept Index</h2>

<ul class="index-cp" compact>
<li><a href="#index-aes_005fdecrypt-81"><code>aes_decrypt</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-aes_005fencrypt-80"><code>aes_encrypt</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-aes_005finvert_005fkey-79"><code>aes_invert_key</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-aes_005fset_005fdecrypt_005fkey-78"><code>aes_set_decrypt_key</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-aes_005fset_005fencrypt_005fkey-77"><code>aes_set_encrypt_key</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-arcfour_005fcrypt-87"><code>arcfour_crypt</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-arcfour_005fset_005fkey-86"><code>arcfour_set_key</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-arctwo_005fdecrypt-97"><code>arctwo_decrypt</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-arctwo_005fencrypt-96"><code>arctwo_encrypt</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-arctwo_005fset_005fkey-94"><code>arctwo_set_key</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-arctwo_005fset_005fkey_005fekb-93"><code>arctwo_set_key_ekb</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-arctwo_005fset_005fkey_005fgutmann-95"><code>arctwo_set_key_gutmann</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-Block-Cipher-70">Block Cipher</a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-blowfish_005fdecrypt-105"><code>blowfish_decrypt</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-blowfish_005fencrypt-104"><code>blowfish_encrypt</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-blowfish_005fset_005fkey-103"><code>blowfish_set_key</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-camellia_005fcrypt-114"><code>camellia_crypt</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-camellia_005finvert_005fkey-113"><code>camellia_invert_key</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-camellia_005fset_005fdecrypt_005fkey-112"><code>camellia_set_decrypt_key</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-camellia_005fset_005fencrypt_005fkey-111"><code>camellia_set_encrypt_key</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-cast128_005fdecrypt-122"><code>cast128_decrypt</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-cast128_005fencrypt-121"><code>cast128_encrypt</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-cast128_005fset_005fkey-120"><code>cast128_set_key</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-CBC-Mode-174">CBC Mode</a>: <a href="#CBC">CBC</a></li>
<li><a href="#index-CBC_005fCTX-177"><code>CBC_CTX</code></a>: <a href="#CBC">CBC</a></li>
<li><a href="#index-CBC_005fDECRYPT-180"><code>CBC_DECRYPT</code></a>: <a href="#CBC">CBC</a></li>
<li><a href="#index-cbc_005fdecrypt-176"><code>cbc_decrypt</code></a>: <a href="#CBC">CBC</a></li>
<li><a href="#index-CBC_005fENCRYPT-179"><code>CBC_ENCRYPT</code></a>: <a href="#CBC">CBC</a></li>
<li><a href="#index-cbc_005fencrypt-175"><code>cbc_encrypt</code></a>: <a href="#CBC">CBC</a></li>
<li><a href="#index-CBC_005fSET_005fIV-178"><code>CBC_SET_IV</code></a>: <a href="#CBC">CBC</a></li>
<li><a href="#index-Cipher-69">Cipher</a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-Cipher-Block-Chaining-173">Cipher Block Chaining</a>: <a href="#CBC">CBC</a></li>
<li><a href="#index-Collision_002dresistant-3">Collision-resistant</a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-Conditional-entropy-290">Conditional entropy</a>: <a href="#Randomness">Randomness</a></li>
<li><a href="#index-Counter-Mode-181">Counter Mode</a>: <a href="#CTR">CTR</a></li>
<li><a href="#index-CTR-Mode-182">CTR Mode</a>: <a href="#CTR">CTR</a></li>
<li><a href="#index-CTR_005fCRYPT-186"><code>CTR_CRYPT</code></a>: <a href="#CTR">CTR</a></li>
<li><a href="#index-ctr_005fcrypt-183"><code>ctr_crypt</code></a>: <a href="#CTR">CTR</a></li>
<li><a href="#index-CTR_005fCTX-184"><code>CTR_CTX</code></a>: <a href="#CTR">CTR</a></li>
<li><a href="#index-CTR_005fSET_005fCOUNTER-185"><code>CTR_SET_COUNTER</code></a>: <a href="#CTR">CTR</a></li>
<li><a href="#index-des3_005fdecrypt-136"><code>des3_decrypt</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-des3_005fencrypt-135"><code>des3_encrypt</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-des3_005fset_005fkey-134"><code>des3_set_key</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-des_005fcheck_005fparity-129"><code>des_check_parity</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-des_005fdecrypt-128"><code>des_decrypt</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-des_005fencrypt-127"><code>des_encrypt</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-des_005ffix_005fparity-130"><code>des_fix_parity</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-des_005fset_005fkey-126"><code>des_set_key</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-dsa_005fgenerate_005fkeypair-287"><code>dsa_generate_keypair</code></a>: <a href="#DSA">DSA</a></li>
<li><a href="#index-dsa_005fprivate_005fkey_005fclear-275"><code>dsa_private_key_clear</code></a>: <a href="#DSA">DSA</a></li>
<li><a href="#index-dsa_005fprivate_005fkey_005finit-273"><code>dsa_private_key_init</code></a>: <a href="#DSA">DSA</a></li>
<li><a href="#index-dsa_005fpublic_005fkey_005fclear-274"><code>dsa_public_key_clear</code></a>: <a href="#DSA">DSA</a></li>
<li><a href="#index-dsa_005fpublic_005fkey_005finit-272"><code>dsa_public_key_init</code></a>: <a href="#DSA">DSA</a></li>
<li><a href="#index-dsa_005fsha1_005fsign-279"><code>dsa_sha1_sign</code></a>: <a href="#DSA">DSA</a></li>
<li><a href="#index-dsa_005fsha1_005fsign_005fdigest-280"><code>dsa_sha1_sign_digest</code></a>: <a href="#DSA">DSA</a></li>
<li><a href="#index-dsa_005fsha1_005fverify-283"><code>dsa_sha1_verify</code></a>: <a href="#DSA">DSA</a></li>
<li><a href="#index-dsa_005fsha1_005fverify_005fdigest-284"><code>dsa_sha1_verify_digest</code></a>: <a href="#DSA">DSA</a></li>
<li><a href="#index-dsa_005fsha256_005fsign-281"><code>dsa_sha256_sign</code></a>: <a href="#DSA">DSA</a></li>
<li><a href="#index-dsa_005fsha256_005fsign_005fdigest-282"><code>dsa_sha256_sign_digest</code></a>: <a href="#DSA">DSA</a></li>
<li><a href="#index-dsa_005fsha256_005fverify-285"><code>dsa_sha256_verify</code></a>: <a href="#DSA">DSA</a></li>
<li><a href="#index-dsa_005fsha256_005fverify_005fdigest-286"><code>dsa_sha256_verify_digest</code></a>: <a href="#DSA">DSA</a></li>
<li><a href="#index-dsa_005fsignature_005fclear-278"><code>dsa_signature_clear</code></a>: <a href="#DSA">DSA</a></li>
<li><a href="#index-dsa_005fsignature_005finit-277"><code>dsa_signature_init</code></a>: <a href="#DSA">DSA</a></li>
<li><a href="#index-Entropy-289">Entropy</a>: <a href="#Randomness">Randomness</a></li>
<li><a href="#index-Galois-Counter-Mode-187">Galois Counter Mode</a>: <a href="#GCM">GCM</a></li>
<li><a href="#index-GCM-188">GCM</a>: <a href="#GCM">GCM</a></li>
<li><a href="#index-gcm_005faes_005fdecrypt-211"><code>gcm_aes_decrypt</code></a>: <a href="#GCM">GCM</a></li>
<li><a href="#index-gcm_005faes_005fdigest-212"><code>gcm_aes_digest</code></a>: <a href="#GCM">GCM</a></li>
<li><a href="#index-gcm_005faes_005fencrypt-210"><code>gcm_aes_encrypt</code></a>: <a href="#GCM">GCM</a></li>
<li><a href="#index-gcm_005faes_005fset_005fiv-208"><code>gcm_aes_set_iv</code></a>: <a href="#GCM">GCM</a></li>
<li><a href="#index-gcm_005faes_005fset_005fkey-207"><code>gcm_aes_set_key</code></a>: <a href="#GCM">GCM</a></li>
<li><a href="#index-gcm_005faes_005fupdate-209"><code>gcm_aes_update</code></a>: <a href="#GCM">GCM</a></li>
<li><a href="#index-GCM_005fCTX-199"><code>GCM_CTX</code></a>: <a href="#GCM">GCM</a></li>
<li><a href="#index-GCM_005fDECRYPT-204"><code>GCM_DECRYPT</code></a>: <a href="#GCM">GCM</a></li>
<li><a href="#index-gcm_005fdecrypt-197"><code>gcm_decrypt</code></a>: <a href="#GCM">GCM</a></li>
<li><a href="#index-GCM_005fDIGEST-205"><code>GCM_DIGEST</code></a>: <a href="#GCM">GCM</a></li>
<li><a href="#index-gcm_005fdigest-198"><code>gcm_digest</code></a>: <a href="#GCM">GCM</a></li>
<li><a href="#index-GCM_005fENCRYPT-203"><code>GCM_ENCRYPT</code></a>: <a href="#GCM">GCM</a></li>
<li><a href="#index-gcm_005fencrypt-196"><code>gcm_encrypt</code></a>: <a href="#GCM">GCM</a></li>
<li><a href="#index-GCM_005fSET_005fIV-201"><code>GCM_SET_IV</code></a>: <a href="#GCM">GCM</a></li>
<li><a href="#index-gcm_005fset_005fiv-194"><code>gcm_set_iv</code></a>: <a href="#GCM">GCM</a></li>
<li><a href="#index-GCM_005fSET_005fKEY-200"><code>GCM_SET_KEY</code></a>: <a href="#GCM">GCM</a></li>
<li><a href="#index-gcm_005fset_005fkey-193"><code>gcm_set_key</code></a>: <a href="#GCM">GCM</a></li>
<li><a href="#index-GCM_005fUPDATE-202"><code>GCM_UPDATE</code></a>: <a href="#GCM">GCM</a></li>
<li><a href="#index-gcm_005fupdate-195"><code>gcm_update</code></a>: <a href="#GCM">GCM</a></li>
<li><a href="#index-Hash-function-1">Hash function</a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-HMAC_005fCTX-219"><code>HMAC_CTX</code></a>: <a href="#Keyed-hash-functions">Keyed hash functions</a></li>
<li><a href="#index-HMAC_005fDIGEST-221"><code>HMAC_DIGEST</code></a>: <a href="#Keyed-hash-functions">Keyed hash functions</a></li>
<li><a href="#index-hmac_005fdigest-218"><code>hmac_digest</code></a>: <a href="#Keyed-hash-functions">Keyed hash functions</a></li>
<li><a href="#index-hmac_005fmd5_005fdigest-225"><code>hmac_md5_digest</code></a>: <a href="#Keyed-hash-functions">Keyed hash functions</a></li>
<li><a href="#index-hmac_005fmd5_005fset_005fkey-223"><code>hmac_md5_set_key</code></a>: <a href="#Keyed-hash-functions">Keyed hash functions</a></li>
<li><a href="#index-hmac_005fmd5_005fupdate-224"><code>hmac_md5_update</code></a>: <a href="#Keyed-hash-functions">Keyed hash functions</a></li>
<li><a href="#index-hmac_005fripemd160_005fdigest-229"><code>hmac_ripemd160_digest</code></a>: <a href="#Keyed-hash-functions">Keyed hash functions</a></li>
<li><a href="#index-hmac_005fripemd160_005fset_005fkey-227"><code>hmac_ripemd160_set_key</code></a>: <a href="#Keyed-hash-functions">Keyed hash functions</a></li>
<li><a href="#index-hmac_005fripemd160_005fupdate-228"><code>hmac_ripemd160_update</code></a>: <a href="#Keyed-hash-functions">Keyed hash functions</a></li>
<li><a href="#index-HMAC_005fSET_005fKEY-220"><code>HMAC_SET_KEY</code></a>: <a href="#Keyed-hash-functions">Keyed hash functions</a></li>
<li><a href="#index-hmac_005fset_005fkey-216"><code>hmac_set_key</code></a>: <a href="#Keyed-hash-functions">Keyed hash functions</a></li>
<li><a href="#index-hmac_005fsha1_005fdigest-233"><code>hmac_sha1_digest</code></a>: <a href="#Keyed-hash-functions">Keyed hash functions</a></li>
<li><a href="#index-hmac_005fsha1_005fset_005fkey-231"><code>hmac_sha1_set_key</code></a>: <a href="#Keyed-hash-functions">Keyed hash functions</a></li>
<li><a href="#index-hmac_005fsha1_005fupdate-232"><code>hmac_sha1_update</code></a>: <a href="#Keyed-hash-functions">Keyed hash functions</a></li>
<li><a href="#index-hmac_005fsha256_005fdigest-237"><code>hmac_sha256_digest</code></a>: <a href="#Keyed-hash-functions">Keyed hash functions</a></li>
<li><a href="#index-hmac_005fsha256_005fset_005fkey-235"><code>hmac_sha256_set_key</code></a>: <a href="#Keyed-hash-functions">Keyed hash functions</a></li>
<li><a href="#index-hmac_005fsha256_005fupdate-236"><code>hmac_sha256_update</code></a>: <a href="#Keyed-hash-functions">Keyed hash functions</a></li>
<li><a href="#index-hmac_005fsha512_005fdigest-241"><code>hmac_sha512_digest</code></a>: <a href="#Keyed-hash-functions">Keyed hash functions</a></li>
<li><a href="#index-hmac_005fsha512_005fset_005fkey-239"><code>hmac_sha512_set_key</code></a>: <a href="#Keyed-hash-functions">Keyed hash functions</a></li>
<li><a href="#index-hmac_005fsha512_005fupdate-240"><code>hmac_sha512_update</code></a>: <a href="#Keyed-hash-functions">Keyed hash functions</a></li>
<li><a href="#index-hmac_005fupdate-217"><code>hmac_update</code></a>: <a href="#Keyed-hash-functions">Keyed hash functions</a></li>
<li><a href="#index-Keyed-Hash-Function-213">Keyed Hash Function</a>: <a href="#Keyed-hash-functions">Keyed hash functions</a></li>
<li><a href="#index-MAC-215">MAC</a>: <a href="#Keyed-hash-functions">Keyed hash functions</a></li>
<li><a href="#index-md2_005fdigest-15"><code>md2_digest</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-md2_005finit-13"><code>md2_init</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-md2_005fupdate-14"><code>md2_update</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-md4_005fdigest-21"><code>md4_digest</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-md4_005finit-19"><code>md4_init</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-md4_005fupdate-20"><code>md4_update</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-md5_005fdigest-9"><code>md5_digest</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-md5_005finit-7"><code>md5_init</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-md5_005fupdate-8"><code>md5_update</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-memxor-305"><code>memxor</code></a>: <a href="#Miscellaneous-functions">Miscellaneous functions</a></li>
<li><a href="#index-Message-Authentication-Code-214">Message Authentication Code</a>: <a href="#Keyed-hash-functions">Keyed hash functions</a></li>
<li><a href="#index-One_002dway-2">One-way</a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-One_002dway-function-243">One-way function</a>: <a href="#Public_002dkey-algorithms">Public-key algorithms</a></li>
<li><a href="#index-Public-Key-Cryptography-242">Public Key Cryptography</a>: <a href="#Public_002dkey-algorithms">Public-key algorithms</a></li>
<li><a href="#index-Randomness-288">Randomness</a>: <a href="#Randomness">Randomness</a></li>
<li><a href="#index-ripemd160_005fdigest-27"><code>ripemd160_digest</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-ripemd160_005finit-25"><code>ripemd160_init</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-ripemd160_005fupdate-26"><code>ripemd160_update</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-rsa_005fcompute_005froot-268"><code>rsa_compute_root</code></a>: <a href="#RSA">RSA</a></li>
<li><a href="#index-rsa_005fgenerate_005fkeypair-269"><code>rsa_generate_keypair</code></a>: <a href="#RSA">RSA</a></li>
<li><a href="#index-rsa_005fmd5_005fsign-252"><code>rsa_md5_sign</code></a>: <a href="#RSA">RSA</a></li>
<li><a href="#index-rsa_005fmd5_005fsign_005fdigest-256"><code>rsa_md5_sign_digest</code></a>: <a href="#RSA">RSA</a></li>
<li><a href="#index-rsa_005fmd5_005fverify-260"><code>rsa_md5_verify</code></a>: <a href="#RSA">RSA</a></li>
<li><a href="#index-rsa_005fmd5_005fverify_005fdigest-264"><code>rsa_md5_verify_digest</code></a>: <a href="#RSA">RSA</a></li>
<li><a href="#index-rsa_005fprivate_005fkey_005fclear-249"><code>rsa_private_key_clear</code></a>: <a href="#RSA">RSA</a></li>
<li><a href="#index-rsa_005fprivate_005fkey_005finit-247"><code>rsa_private_key_init</code></a>: <a href="#RSA">RSA</a></li>
<li><a href="#index-rsa_005fprivate_005fkey_005fprepare-251"><code>rsa_private_key_prepare</code></a>: <a href="#RSA">RSA</a></li>
<li><a href="#index-rsa_005fpublic_005fkey_005fclear-248"><code>rsa_public_key_clear</code></a>: <a href="#RSA">RSA</a></li>
<li><a href="#index-rsa_005fpublic_005fkey_005finit-246"><code>rsa_public_key_init</code></a>: <a href="#RSA">RSA</a></li>
<li><a href="#index-rsa_005fpublic_005fkey_005fprepare-250"><code>rsa_public_key_prepare</code></a>: <a href="#RSA">RSA</a></li>
<li><a href="#index-rsa_005fsha1_005fsign-253"><code>rsa_sha1_sign</code></a>: <a href="#RSA">RSA</a></li>
<li><a href="#index-rsa_005fsha1_005fsign_005fdigest-257"><code>rsa_sha1_sign_digest</code></a>: <a href="#RSA">RSA</a></li>
<li><a href="#index-rsa_005fsha1_005fverify-261"><code>rsa_sha1_verify</code></a>: <a href="#RSA">RSA</a></li>
<li><a href="#index-rsa_005fsha1_005fverify_005fdigest-265"><code>rsa_sha1_verify_digest</code></a>: <a href="#RSA">RSA</a></li>
<li><a href="#index-rsa_005fsha256_005fsign-254"><code>rsa_sha256_sign</code></a>: <a href="#RSA">RSA</a></li>
<li><a href="#index-rsa_005fsha256_005fsign_005fdigest-258"><code>rsa_sha256_sign_digest</code></a>: <a href="#RSA">RSA</a></li>
<li><a href="#index-rsa_005fsha256_005fverify-262"><code>rsa_sha256_verify</code></a>: <a href="#RSA">RSA</a></li>
<li><a href="#index-rsa_005fsha256_005fverify_005fdigest-266"><code>rsa_sha256_verify_digest</code></a>: <a href="#RSA">RSA</a></li>
<li><a href="#index-rsa_005fsha512_005fsign-255"><code>rsa_sha512_sign</code></a>: <a href="#RSA">RSA</a></li>
<li><a href="#index-rsa_005fsha512_005fsign_005fdigest-259"><code>rsa_sha512_sign_digest</code></a>: <a href="#RSA">RSA</a></li>
<li><a href="#index-rsa_005fsha512_005fverify-263"><code>rsa_sha512_verify</code></a>: <a href="#RSA">RSA</a></li>
<li><a href="#index-rsa_005fsha512_005fverify_005fdigest-267"><code>rsa_sha512_verify_digest</code></a>: <a href="#RSA">RSA</a></li>
<li><a href="#index-serpent_005fdecrypt-144"><code>serpent_decrypt</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-serpent_005fencrypt-143"><code>serpent_encrypt</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-serpent_005fset_005fkey-142"><code>serpent_set_key</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-sha1_005fdigest-33"><code>sha1_digest</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-sha1_005finit-31"><code>sha1_init</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-sha1_005fupdate-32"><code>sha1_update</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-sha224_005fdigest-45"><code>sha224_digest</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-sha224_005finit-43"><code>sha224_init</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-sha224_005fupdate-44"><code>sha224_update</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-sha256_005fdigest-39"><code>sha256_digest</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-sha256_005finit-37"><code>sha256_init</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-sha256_005fupdate-38"><code>sha256_update</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-sha384_005fdigest-57"><code>sha384_digest</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-sha384_005finit-55"><code>sha384_init</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-sha384_005fupdate-56"><code>sha384_update</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-sha512_005fdigest-51"><code>sha512_digest</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-sha512_005finit-49"><code>sha512_init</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-sha512_005fupdate-50"><code>sha512_update</code></a>: <a href="#Hash-functions">Hash functions</a></li>
<li><a href="#index-Stream-Cipher-71">Stream Cipher</a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-twofish_005fdecrypt-152"><code>twofish_decrypt</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-twofish_005fencrypt-151"><code>twofish_encrypt</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-twofish_005fset_005fkey-150"><code>twofish_set_key</code></a>: <a href="#Cipher-functions">Cipher functions</a></li>
<li><a href="#index-yarrow256_005ffast_005freseed-300"><code>yarrow256_fast_reseed</code></a>: <a href="#Randomness">Randomness</a></li>
<li><a href="#index-yarrow256_005finit-294"><code>yarrow256_init</code></a>: <a href="#Randomness">Randomness</a></li>
<li><a href="#index-yarrow256_005fis_005fseeded-298"><code>yarrow256_is_seeded</code></a>: <a href="#Randomness">Randomness</a></li>
<li><a href="#index-yarrow256_005fneeded_005fsources-299"><code>yarrow256_needed_sources</code></a>: <a href="#Randomness">Randomness</a></li>
<li><a href="#index-yarrow256_005frandom-297"><code>yarrow256_random</code></a>: <a href="#Randomness">Randomness</a></li>
<li><a href="#index-yarrow256_005fseed-295"><code>yarrow256_seed</code></a>: <a href="#Randomness">Randomness</a></li>
<li><a href="#index-yarrow256_005fslow_005freseed-301"><code>yarrow256_slow_reseed</code></a>: <a href="#Randomness">Randomness</a></li>
<li><a href="#index-yarrow256_005fupdate-296"><code>yarrow256_update</code></a>: <a href="#Randomness">Randomness</a></li>
<li><a href="#index-yarrow_005fkey_005fevent_005festimate-304"><code>yarrow_key_event_estimate</code></a>: <a href="#Randomness">Randomness</a></li>
<li><a href="#index-yarrow_005fkey_005fevent_005finit-303"><code>yarrow_key_event_init</code></a>: <a href="#Randomness">Randomness</a></li>
   </ul><div class="footnote">
<hr>
<a name="texinfo-footnotes-in-document"></a><h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> Actually, the computation is not done like this, it is
done more efficiently using <code>p</code>, <code>q</code> and the Chinese remainder
theorem (<acronym>CRT</acronym>). But the result is the same.</p>

   <hr></div>

</body></html>

<!--

Local Variables:
coding: iso-8859-1
End:

-->
